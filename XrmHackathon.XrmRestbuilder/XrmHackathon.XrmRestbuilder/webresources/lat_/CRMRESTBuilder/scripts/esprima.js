//http://esprima.org/
/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
!function (b, c) { "object" == typeof exports && "object" == typeof module ? module.exports = c() : "function" == typeof define && define.amd ? define([], c) : "object" == typeof exports ? exports.esprima = c() : b.esprima = c() }(this, function () {
	return function (a) { function c(d) { if (b[d]) return b[d].exports; var e = b[d] = { exports: {}, id: d, loaded: !1 }; return a[d].call(e.exports, e, e.exports, c), e.loaded = !0, e.exports } var b = {}; return c.m = a, c.c = b, c.p = "", c(0) }([function (a, b, c) { "use strict"; function h(a, b, c) { var g = null, h = function (a, b) { c && c(a, b), g && g.visit(a, b) }, i = "function" == typeof c ? h : null, j = !1; if (b) { j = "boolean" == typeof b.comment && b.comment; var k = "boolean" == typeof b.attachComment && b.attachComment; (j || k) && (g = new d.CommentHandler, g.attach = k, b.comment = !0, i = h) } var l; l = b && "boolean" == typeof b.jsx && b.jsx ? new f.JSXParser(a, b, i) : new e.Parser(a, b, i); var m = l.parseProgram(); return j && (m.comments = g.comments), l.config.tokens && (m.tokens = l.tokens), l.config.tolerant && (m.errors = l.errorHandler.errors), m } function i(a, b, c) { var e, d = new g.Tokenizer(a, b); e = []; try { for (; ;) { var f = d.getNextToken(); if (!f) break; c && (f = c(f)), e.push(f) } } catch (a) { d.errorHandler.tolerate(a) } return d.errorHandler.tolerant && (e.errors = d.errors()), e } var d = c(1), e = c(3), f = c(11), g = c(15); b.parse = h, b.tokenize = i; var j = c(2); b.Syntax = j.Syntax, b.version = "3.1.0" }, function (a, b, c) { "use strict"; var d = c(2), e = function () { function a() { this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [] } return a.prototype.insertInnerComments = function (a, b) { if (a.type === d.Syntax.BlockStatement && 0 === a.body.length) { for (var c = [], e = this.leading.length - 1; e >= 0; --e) { var f = this.leading[e]; b.end.offset >= f.start && (c.unshift(f.comment), this.leading.splice(e, 1), this.trailing.splice(e, 1)) } c.length && (a.innerComments = c) } }, a.prototype.findTrailingComments = function (a, b) { var c = []; if (this.trailing.length > 0) { for (var d = this.trailing.length - 1; d >= 0; --d) { var e = this.trailing[d]; e.start >= b.end.offset && c.unshift(e.comment) } return this.trailing.length = 0, c } var f = this.stack[this.stack.length - 1]; if (f && f.node.trailingComments) { var g = f.node.trailingComments[0]; g && g.range[0] >= b.end.offset && (c = f.node.trailingComments, delete f.node.trailingComments) } return c }, a.prototype.findLeadingComments = function (a, b) { for (var d, c = []; this.stack.length > 0;) { var e = this.stack[this.stack.length - 1]; if (!(e && e.start >= b.start.offset)) break; d = this.stack.pop().node } if (d) { for (var f = d.leadingComments ? d.leadingComments.length : 0, g = f - 1; g >= 0; --g) { var h = d.leadingComments[g]; h.range[1] <= b.start.offset && (c.unshift(h), d.leadingComments.splice(g, 1)) } return d.leadingComments && 0 === d.leadingComments.length && delete d.leadingComments, c } for (var g = this.leading.length - 1; g >= 0; --g) { var e = this.leading[g]; e.start <= b.start.offset && (c.unshift(e.comment), this.leading.splice(g, 1)) } return c }, a.prototype.visitNode = function (a, b) { if (!(a.type === d.Syntax.Program && a.body.length > 0)) { this.insertInnerComments(a, b); var c = this.findTrailingComments(a, b), e = this.findLeadingComments(a, b); e.length > 0 && (a.leadingComments = e), c.length > 0 && (a.trailingComments = c), this.stack.push({ node: a, start: b.start.offset }) } }, a.prototype.visitComment = function (a, b) { var c = "L" === a.type[0] ? "Line" : "Block", d = { type: c, value: a.value }; if (a.range && (d.range = a.range), a.loc && (d.loc = a.loc), this.comments.push(d), this.attach) { var e = { comment: { type: c, value: a.value, range: [b.start.offset, b.end.offset] }, start: b.start.offset }; a.loc && (e.comment.loc = a.loc), a.type = c, this.leading.push(e), this.trailing.push(e) } }, a.prototype.visit = function (a, b) { "LineComment" === a.type ? this.visitComment(a, b) : "BlockComment" === a.type ? this.visitComment(a, b) : this.attach && this.visitNode(a, b) }, a }(); b.CommentHandler = e }, function (a, b) { "use strict"; b.Syntax = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DoWhileStatement: "DoWhileStatement", DebuggerStatement: "DebuggerStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForOfStatement: "ForOfStatement", ForInStatement: "ForInStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchCase: "SwitchCase", SwitchStatement: "SwitchStatement", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" } }, function (a, b, c) {
		"use strict"; var d = c(4), e = c(5), f = c(6), g = c(7), h = c(8), i = c(2), j = c(10), k = "ArrowParameterPlaceHolder", l = function () {
			function a(a, b, c) { void 0 === b && (b = {}), this.config = { range: "boolean" == typeof b.range && b.range, loc: "boolean" == typeof b.loc && b.loc, source: null, tokens: "boolean" == typeof b.tokens && b.tokens, comment: "boolean" == typeof b.comment && b.comment, tolerant: "boolean" == typeof b.tolerant && b.tolerant }, this.config.loc && b.source && null !== b.source && (this.config.source = String(b.source)), this.delegate = c, this.errorHandler = new f.ErrorHandler, this.errorHandler.tolerant = this.config.tolerant, this.scanner = new h.Scanner(a, this.errorHandler), this.scanner.trackComment = this.config.comment, this.operatorPrecedence = { ")": 0, ";": 0, ",": 0, "=": 0, "]": 0, "||": 1, "&&": 2, "|": 3, "^": 4, "&": 5, "==": 6, "!=": 6, "===": 6, "!==": 6, "<": 7, ">": 7, "<=": 7, ">=": 7, "<<": 8, ">>": 8, ">>>": 8, "+": 9, "-": 9, "*": 11, "/": 11, "%": 11 }, this.sourceType = b && "module" === b.sourceType ? "module" : "script", this.lookahead = null, this.hasLineTerminator = !1, this.context = { allowIn: !0, allowYield: !0, firstCoverInitializedNameError: null, isAssignmentTarget: !1, isBindingElement: !1, inFunctionBody: !1, inIteration: !1, inSwitch: !1, labelSet: {}, strict: "module" === this.sourceType }, this.tokens = [], this.startMarker = { index: 0, lineNumber: this.scanner.lineNumber, lineStart: 0 }, this.lastMarker = { index: 0, lineNumber: this.scanner.lineNumber, lineStart: 0 }, this.nextToken(), this.lastMarker = { index: this.scanner.index, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart } } return a.prototype.throwError = function (a) { for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c]; var e = Array.prototype.slice.call(arguments, 1), f = a.replace(/%(\d)/g, function (a, b) { return d.assert(b < e.length, "Message reference must be in range"), e[b] }), g = this.lastMarker.index, h = this.lastMarker.lineNumber, i = this.lastMarker.index - this.lastMarker.lineStart + 1; throw this.errorHandler.createError(g, h, i, f) }, a.prototype.tolerateError = function (a) { for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c]; var e = Array.prototype.slice.call(arguments, 1), f = a.replace(/%(\d)/g, function (a, b) { return d.assert(b < e.length, "Message reference must be in range"), e[b] }), g = this.lastMarker.index, h = this.scanner.lineNumber, i = this.lastMarker.index - this.lastMarker.lineStart + 1; this.errorHandler.tolerateError(g, h, i, f) }, a.prototype.unexpectedTokenError = function (a, b) { var d, c = b || e.Messages.UnexpectedToken; if (a ? (b || (c = a.type === g.Token.EOF ? e.Messages.UnexpectedEOS : a.type === g.Token.Identifier ? e.Messages.UnexpectedIdentifier : a.type === g.Token.NumericLiteral ? e.Messages.UnexpectedNumber : a.type === g.Token.StringLiteral ? e.Messages.UnexpectedString : a.type === g.Token.Template ? e.Messages.UnexpectedTemplate : e.Messages.UnexpectedToken, a.type === g.Token.Keyword && (this.scanner.isFutureReservedWord(a.value) ? c = e.Messages.UnexpectedReserved : this.context.strict && this.scanner.isStrictModeReservedWord(a.value) && (c = e.Messages.StrictReservedWord))), d = a.type === g.Token.Template ? a.value.raw : a.value) : d = "ILLEGAL", c = c.replace("%0", d), a && "number" == typeof a.lineNumber) { var f = a.start, h = a.lineNumber, i = a.start - this.lastMarker.lineStart + 1; return this.errorHandler.createError(f, h, i, c) } var f = this.lastMarker.index, h = this.lastMarker.lineNumber, i = f - this.lastMarker.lineStart + 1; return this.errorHandler.createError(f, h, i, c) }, a.prototype.throwUnexpectedToken = function (a, b) { throw this.unexpectedTokenError(a, b) }, a.prototype.tolerateUnexpectedToken = function (a, b) { this.errorHandler.tolerate(this.unexpectedTokenError(a, b)) }, a.prototype.collectComments = function () { if (this.config.comment) { var a = this.scanner.scanComments(); if (a.length > 0 && this.delegate) for (var b = 0; b < a.length; ++b) { var c = a[b], d = void 0; d = { type: c.multiLine ? "BlockComment" : "LineComment", value: this.scanner.source.slice(c.slice[0], c.slice[1]) }, this.config.range && (d.range = c.range), this.config.loc && (d.loc = c.loc); var e = { start: { line: c.loc.start.line, column: c.loc.start.column, offset: c.range[0] }, end: { line: c.loc.end.line, column: c.loc.end.column, offset: c.range[1] } }; this.delegate(d, e) } } else this.scanner.scanComments() }, a.prototype.getTokenRaw = function (a) { return this.scanner.source.slice(a.start, a.end) }, a.prototype.convertToken = function (a) { var b; return b = { type: g.TokenName[a.type], value: this.getTokenRaw(a) }, this.config.range && (b.range = [a.start, a.end]), this.config.loc && (b.loc = { start: { line: this.startMarker.lineNumber, column: this.startMarker.index - this.startMarker.lineStart }, end: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }), a.regex && (b.regex = a.regex), b }, a.prototype.nextToken = function () { var a = this.lookahead; this.lastMarker.index = this.scanner.index, this.lastMarker.lineNumber = this.scanner.lineNumber, this.lastMarker.lineStart = this.scanner.lineStart, this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.lineNumber = this.scanner.lineNumber, this.startMarker.lineStart = this.scanner.lineStart; var b; return b = this.scanner.lex(), this.hasLineTerminator = !(!a || !b) && a.lineNumber !== b.lineNumber, b && this.context.strict && b.type === g.Token.Identifier && this.scanner.isStrictModeReservedWord(b.value) && (b.type = g.Token.Keyword), this.lookahead = b, this.config.tokens && b.type !== g.Token.EOF && this.tokens.push(this.convertToken(b)), a }, a.prototype.nextRegexToken = function () { this.collectComments(); var a = this.scanner.scanRegExp(); return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(a))), this.lookahead = a, this.nextToken(), a }, a.prototype.createNode = function () { return { index: this.startMarker.index, line: this.startMarker.lineNumber, column: this.startMarker.index - this.startMarker.lineStart } }, a.prototype.startNode = function (a) { return { index: a.start, line: a.lineNumber, column: a.start - a.lineStart } }, a.prototype.finalize = function (a, b) { if (this.config.range && (b.range = [a.index, this.lastMarker.index]), this.config.loc && (b.loc = { start: { line: a.line, column: a.column }, end: { line: this.lastMarker.lineNumber, column: this.lastMarker.index - this.lastMarker.lineStart } }, this.config.source && (b.loc.source = this.config.source)), this.delegate) { var c = { start: { line: a.line, column: a.column, offset: a.index }, end: { line: this.lastMarker.lineNumber, column: this.lastMarker.index - this.lastMarker.lineStart, offset: this.lastMarker.index } }; this.delegate(b, c) } return b }, a.prototype.expect = function (a) { var b = this.nextToken(); b.type === g.Token.Punctuator && b.value === a || this.throwUnexpectedToken(b) }, a.prototype.expectCommaSeparator = function () { if (this.config.tolerant) { var a = this.lookahead; a.type === g.Token.Punctuator && "," === a.value ? this.nextToken() : a.type === g.Token.Punctuator && ";" === a.value ? (this.nextToken(), this.tolerateUnexpectedToken(a)) : this.tolerateUnexpectedToken(a, e.Messages.UnexpectedToken) } else this.expect(",") }, a.prototype.expectKeyword = function (a) { var b = this.nextToken(); b.type === g.Token.Keyword && b.value === a || this.throwUnexpectedToken(b) }, a.prototype.match = function (a) { return this.lookahead.type === g.Token.Punctuator && this.lookahead.value === a }, a.prototype.matchKeyword = function (a) { return this.lookahead.type === g.Token.Keyword && this.lookahead.value === a }, a.prototype.matchContextualKeyword = function (a) { return this.lookahead.type === g.Token.Identifier && this.lookahead.value === a }, a.prototype.matchAssign = function () { if (this.lookahead.type !== g.Token.Punctuator) return !1; var a = this.lookahead.value; return "=" === a || "*=" === a || "**=" === a || "/=" === a || "%=" === a || "+=" === a || "-=" === a || "<<=" === a || ">>=" === a || ">>>=" === a || "&=" === a || "^=" === a || "|=" === a }, a.prototype.isolateCoverGrammar = function (a) { var b = this.context.isBindingElement, c = this.context.isAssignmentTarget, d = this.context.firstCoverInitializedNameError; this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null; var e = a.call(this); return null !== this.context.firstCoverInitializedNameError && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError), this.context.isBindingElement = b, this.context.isAssignmentTarget = c, this.context.firstCoverInitializedNameError = d, e }, a.prototype.inheritCoverGrammar = function (a) { var b = this.context.isBindingElement, c = this.context.isAssignmentTarget, d = this.context.firstCoverInitializedNameError; this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null; var e = a.call(this); return this.context.isBindingElement = this.context.isBindingElement && b, this.context.isAssignmentTarget = this.context.isAssignmentTarget && c, this.context.firstCoverInitializedNameError = d || this.context.firstCoverInitializedNameError, e }, a.prototype.consumeSemicolon = function () { this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type === g.Token.EOF || this.match("}") || this.throwUnexpectedToken(this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.lineNumber = this.startMarker.lineNumber, this.lastMarker.lineStart = this.startMarker.lineStart) }, a.prototype.parsePrimaryExpression = function () { var b, c, d, f, a = this.createNode(); switch (this.lookahead.type) { case g.Token.Identifier: "module" === this.sourceType && "await" === this.lookahead.value && this.tolerateUnexpectedToken(this.lookahead), b = this.finalize(a, new j.Identifier(this.nextToken().value)); break; case g.Token.NumericLiteral: case g.Token.StringLiteral: this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, e.Messages.StrictOctalLiteral), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, d = this.nextToken(), f = this.getTokenRaw(d), b = this.finalize(a, new j.Literal(d.value, f)); break; case g.Token.BooleanLiteral: this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, d = this.nextToken(), d.value = "true" === d.value, f = this.getTokenRaw(d), b = this.finalize(a, new j.Literal(d.value, f)); break; case g.Token.NullLiteral: this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, d = this.nextToken(), d.value = null, f = this.getTokenRaw(d), b = this.finalize(a, new j.Literal(d.value, f)); break; case g.Token.Template: b = this.parseTemplateLiteral(); break; case g.Token.Punctuator: switch (c = this.lookahead.value) { case "(": this.context.isBindingElement = !1, b = this.inheritCoverGrammar(this.parseGroupExpression); break; case "[": b = this.inheritCoverGrammar(this.parseArrayInitializer); break; case "{": b = this.inheritCoverGrammar(this.parseObjectInitializer); break; case "/": case "/=": this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index, d = this.nextRegexToken(), f = this.getTokenRaw(d), b = this.finalize(a, new j.RegexLiteral(d.value, f, d.regex)); break; default: this.throwUnexpectedToken(this.nextToken()) } break; case g.Token.Keyword: !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? b = this.parseIdentifierName() : !this.context.strict && this.matchKeyword("let") ? b = this.finalize(a, new j.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? b = this.parseFunctionExpression() : this.matchKeyword("this") ? (this.nextToken(), b = this.finalize(a, new j.ThisExpression)) : this.matchKeyword("class") ? b = this.parseClassExpression() : this.throwUnexpectedToken(this.nextToken())); break; default: this.throwUnexpectedToken(this.nextToken()) } return b }, a.prototype.parseSpreadElement = function () { var a = this.createNode(); this.expect("..."); var b = this.inheritCoverGrammar(this.parseAssignmentExpression); return this.finalize(a, new j.SpreadElement(b)) }, a.prototype.parseArrayInitializer = function () { var a = this.createNode(), b = []; for (this.expect("[") ; !this.match("]") ;) if (this.match(",")) this.nextToken(), b.push(null); else if (this.match("...")) { var c = this.parseSpreadElement(); this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), b.push(c) } else b.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(","); return this.expect("]"), this.finalize(a, new j.ArrayExpression(b)) }, a.prototype.parsePropertyMethod = function (a) { this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; var b = this.context.strict, c = this.isolateCoverGrammar(this.parseFunctionSourceElements); return this.context.strict && a.firstRestricted && this.tolerateUnexpectedToken(a.firstRestricted, a.message), this.context.strict && a.stricted && this.tolerateUnexpectedToken(a.stricted, a.message), this.context.strict = b, c }, a.prototype.parsePropertyMethodFunction = function () { var a = !1, b = this.createNode(), c = this.context.allowYield; this.context.allowYield = !1; var d = this.parseFormalParameters(), e = this.parsePropertyMethod(d); return this.context.allowYield = c, this.finalize(b, new j.FunctionExpression(null, d.params, e, a)) }, a.prototype.parseObjectPropertyKey = function () { var a = this.createNode(), b = this.nextToken(), c = null; switch (b.type) { case g.Token.StringLiteral: case g.Token.NumericLiteral: this.context.strict && b.octal && this.tolerateUnexpectedToken(b, e.Messages.StrictOctalLiteral); var d = this.getTokenRaw(b); c = this.finalize(a, new j.Literal(b.value, d)); break; case g.Token.Identifier: case g.Token.BooleanLiteral: case g.Token.NullLiteral: case g.Token.Keyword: c = this.finalize(a, new j.Identifier(b.value)); break; case g.Token.Punctuator: "[" === b.value ? (c = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : this.throwUnexpectedToken(b); break; default: this.throwUnexpectedToken(b) } return c }, a.prototype.isPropertyKey = function (a, b) { return a.type === i.Syntax.Identifier && a.name === b || a.type === i.Syntax.Literal && a.value === b }, a.prototype.parseObjectProperty = function (a) { var d, f, h, b = this.createNode(), c = this.lookahead, i = !1, k = !1, l = !1; c.type === g.Token.Identifier ? (this.nextToken(), f = this.finalize(b, new j.Identifier(c.value))) : this.match("*") ? this.nextToken() : (i = this.match("["), f = this.parseObjectPropertyKey()); var m = this.qualifiedPropertyName(this.lookahead); if (c.type === g.Token.Identifier && "get" === c.value && m) d = "get", i = this.match("["), f = this.parseObjectPropertyKey(), this.context.allowYield = !1, h = this.parseGetterMethod(); else if (c.type === g.Token.Identifier && "set" === c.value && m) d = "set", i = this.match("["), f = this.parseObjectPropertyKey(), h = this.parseSetterMethod(); else if (c.type === g.Token.Punctuator && "*" === c.value && m) d = "init", i = this.match("["), f = this.parseObjectPropertyKey(), h = this.parseGeneratorMethod(), k = !0; else if (f || this.throwUnexpectedToken(this.lookahead), d = "init", this.match(":")) !i && this.isPropertyKey(f, "__proto__") && (a.value && this.tolerateError(e.Messages.DuplicateProtoProperty), a.value = !0), this.nextToken(), h = this.inheritCoverGrammar(this.parseAssignmentExpression); else if (this.match("(")) h = this.parsePropertyMethodFunction(), k = !0; else if (c.type === g.Token.Identifier) { var n = this.finalize(b, new j.Identifier(c.value)); if (this.match("=")) { this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), l = !0; var o = this.isolateCoverGrammar(this.parseAssignmentExpression); h = this.finalize(b, new j.AssignmentPattern(n, o)) } else l = !0, h = n } else this.throwUnexpectedToken(this.nextToken()); return this.finalize(b, new j.Property(d, f, i, h, k, l)) }, a.prototype.parseObjectInitializer = function () { var a = this.createNode(); this.expect("{"); for (var b = [], c = { value: !1 }; !this.match("}") ;) b.push(this.parseObjectProperty(c)), this.match("}") || this.expectCommaSeparator(); return this.expect("}"), this.finalize(a, new j.ObjectExpression(b)) }, a.prototype.parseTemplateHead = function () { d.assert(this.lookahead.head, "Template literal must start with a template head"); var a = this.createNode(), b = this.nextToken(), c = { raw: b.value.raw, cooked: b.value.cooked }; return this.finalize(a, new j.TemplateElement(c, b.tail)) }, a.prototype.parseTemplateElement = function () { this.lookahead.type !== g.Token.Template && this.throwUnexpectedToken(); var a = this.createNode(), b = this.nextToken(), c = { raw: b.value.raw, cooked: b.value.cooked }; return this.finalize(a, new j.TemplateElement(c, b.tail)) }, a.prototype.parseTemplateLiteral = function () { var a = this.createNode(), b = [], c = [], d = this.parseTemplateHead(); for (c.push(d) ; !d.tail;) b.push(this.parseExpression()), d = this.parseTemplateElement(), c.push(d); return this.finalize(a, new j.TemplateLiteral(c, b)) }, a.prototype.reinterpretExpressionAsPattern = function (a) { switch (a.type) { case i.Syntax.Identifier: case i.Syntax.MemberExpression: case i.Syntax.RestElement: case i.Syntax.AssignmentPattern: break; case i.Syntax.SpreadElement: a.type = i.Syntax.RestElement, this.reinterpretExpressionAsPattern(a.argument); break; case i.Syntax.ArrayExpression: a.type = i.Syntax.ArrayPattern; for (var b = 0; b < a.elements.length; b++) null !== a.elements[b] && this.reinterpretExpressionAsPattern(a.elements[b]); break; case i.Syntax.ObjectExpression: a.type = i.Syntax.ObjectPattern; for (var b = 0; b < a.properties.length; b++) this.reinterpretExpressionAsPattern(a.properties[b].value); break; case i.Syntax.AssignmentExpression: a.type = i.Syntax.AssignmentPattern, delete a.operator, this.reinterpretExpressionAsPattern(a.left) } }, a.prototype.parseGroupExpression = function () { var a; if (this.expect("("), this.match(")")) this.nextToken(), this.match("=>") || this.expect("=>"), a = { type: k, params: [] }; else { var b = this.lookahead, c = []; if (this.match("...")) a = this.parseRestElement(c), this.expect(")"), this.match("=>") || this.expect("=>"), a = { type: k, params: [a] }; else { var d = !1; if (this.context.isBindingElement = !0, a = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) { var e = []; for (this.context.isAssignmentTarget = !1, e.push(a) ; this.startMarker.index < this.scanner.length && this.match(",") ;) { if (this.nextToken(), this.match("...")) { this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), e.push(this.parseRestElement(c)), this.expect(")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1; for (var f = 0; f < e.length; f++) this.reinterpretExpressionAsPattern(e[f]); d = !0, a = { type: k, params: e } } else e.push(this.inheritCoverGrammar(this.parseAssignmentExpression)); if (d) break } d || (a = this.finalize(this.startNode(b), new j.SequenceExpression(e))) } if (!d) { if (this.expect(")"), this.match("=>") && (a.type === i.Syntax.Identifier && "yield" === a.name && (d = !0, a = { type: k, params: [a] }), !d)) { if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), a.type === i.Syntax.SequenceExpression) for (var f = 0; f < a.expressions.length; f++) this.reinterpretExpressionAsPattern(a.expressions[f]); else this.reinterpretExpressionAsPattern(a); var g = a.type === i.Syntax.SequenceExpression ? a.expressions : [a]; a = { type: k, params: g } } this.context.isBindingElement = !1 } } } return a }, a.prototype.parseArguments = function () { this.expect("("); var a = []; if (!this.match(")")) for (; ;) { var b = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression); if (a.push(b), this.match(")")) break; this.expectCommaSeparator() } return this.expect(")"), a }, a.prototype.isIdentifierName = function (a) { return a.type === g.Token.Identifier || a.type === g.Token.Keyword || a.type === g.Token.BooleanLiteral || a.type === g.Token.NullLiteral }, a.prototype.parseIdentifierName = function () { var a = this.createNode(), b = this.nextToken(); return this.isIdentifierName(b) || this.throwUnexpectedToken(b), this.finalize(a, new j.Identifier(b.value)) }, a.prototype.parseNewExpression = function () { var a = this.createNode(), b = this.parseIdentifierName(); d.assert("new" === b.name, "New expression must start with `new`"); var c; if (this.match(".")) if (this.nextToken(), this.lookahead.type === g.Token.Identifier && this.context.inFunctionBody && "target" === this.lookahead.value) { var e = this.parseIdentifierName(); c = new j.MetaProperty(b, e) } else this.throwUnexpectedToken(this.lookahead); else { var f = this.isolateCoverGrammar(this.parseLeftHandSideExpression), h = this.match("(") ? this.parseArguments() : []; c = new j.NewExpression(f, h), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } return this.finalize(a, c) }, a.prototype.parseLeftHandSideExpressionAllowCall = function () { var a = this.lookahead, b = this.context.allowIn; this.context.allowIn = !0; var c; for (this.matchKeyword("super") && this.context.inFunctionBody ? (c = this.createNode(), this.nextToken(), c = this.finalize(c, new j.Super), this.match("(") || this.match(".") || this.match("[") || this.throwUnexpectedToken(this.lookahead)) : c = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression) ; ;) if (this.match(".")) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("."); var d = this.parseIdentifierName(); c = this.finalize(this.startNode(a), new j.StaticMemberExpression(c, d)) } else if (this.match("(")) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1; var e = this.parseArguments(); c = this.finalize(this.startNode(a), new j.CallExpression(c, e)) } else if (this.match("[")) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("["); var d = this.isolateCoverGrammar(this.parseExpression); this.expect("]"), c = this.finalize(this.startNode(a), new j.ComputedMemberExpression(c, d)) } else { if (this.lookahead.type !== g.Token.Template || !this.lookahead.head) break; var f = this.parseTemplateLiteral(); c = this.finalize(this.startNode(a), new j.TaggedTemplateExpression(c, f)) } return this.context.allowIn = b, c }, a.prototype.parseSuper = function () { var a = this.createNode(); return this.expectKeyword("super"), this.match("[") || this.match(".") || this.throwUnexpectedToken(this.lookahead), this.finalize(a, new j.Super) }, a.prototype.parseLeftHandSideExpression = function () { d.assert(this.context.allowIn, "callee of new expression always allow in keyword."); for (var a = this.startNode(this.lookahead), b = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression) ; ;) if (this.match("[")) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("["); var c = this.isolateCoverGrammar(this.parseExpression); this.expect("]"), b = this.finalize(a, new j.ComputedMemberExpression(b, c)) } else if (this.match(".")) { this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("."); var c = this.parseIdentifierName(); b = this.finalize(a, new j.StaticMemberExpression(b, c)) } else { if (this.lookahead.type !== g.Token.Template || !this.lookahead.head) break; var e = this.parseTemplateLiteral(); b = this.finalize(a, new j.TaggedTemplateExpression(b, e)) } return b }, a.prototype.parseUpdateExpression = function () { var a, b = this.lookahead; if (this.match("++") || this.match("--")) { var c = this.startNode(b), d = this.nextToken(); a = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && a.type === i.Syntax.Identifier && this.scanner.isRestrictedWord(a.name) && this.tolerateError(e.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(e.Messages.InvalidLHSInAssignment); var f = !0; a = this.finalize(c, new j.UpdateExpression(d.value, a, f)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } else if (a = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.type === g.Token.Punctuator && (this.match("++") || this.match("--"))) { this.context.strict && a.type === i.Syntax.Identifier && this.scanner.isRestrictedWord(a.name) && this.tolerateError(e.Messages.StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(e.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; var h = this.nextToken().value, f = !1; a = this.finalize(this.startNode(b), new j.UpdateExpression(h, a, f)) } return a }, a.prototype.parseUnaryExpression = function () { var a; if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) { var b = this.startNode(this.lookahead), c = this.nextToken(); a = this.inheritCoverGrammar(this.parseUnaryExpression), a = this.finalize(b, new j.UnaryExpression(c.value, a)), this.context.strict && "delete" === a.operator && a.argument.type === i.Syntax.Identifier && this.tolerateError(e.Messages.StrictDelete), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } else a = this.parseUpdateExpression(); return a }, a.prototype.parseExponentiationExpression = function () { var a = this.lookahead, b = this.inheritCoverGrammar(this.parseUnaryExpression); if (b.type !== i.Syntax.UnaryExpression && this.match("**")) { this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; var c = b, d = this.isolateCoverGrammar(this.parseExponentiationExpression); b = this.finalize(this.startNode(a), new j.BinaryExpression("**", c, d)) } return b }, a.prototype.binaryPrecedence = function (a) { var c, b = a.value; return c = a.type === g.Token.Punctuator ? this.operatorPrecedence[b] || 0 : a.type === g.Token.Keyword && ("instanceof" === b || this.context.allowIn && "in" === b) ? 7 : 0 }, a.prototype.parseBinaryExpression = function () { var a = this.lookahead, b = this.inheritCoverGrammar(this.parseExponentiationExpression), c = this.lookahead, d = this.binaryPrecedence(c); if (d > 0) { this.nextToken(), c.prec = d, this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; for (var e = [a, this.lookahead], f = b, g = this.isolateCoverGrammar(this.parseExponentiationExpression), h = [f, c, g]; ;) { if (d = this.binaryPrecedence(this.lookahead), d <= 0) break; for (; h.length > 2 && d <= h[h.length - 2].prec;) { g = h.pop(); var i = h.pop().value; f = h.pop(), e.pop(); var k = this.startNode(e[e.length - 1]); h.push(this.finalize(k, new j.BinaryExpression(i, f, g))) } c = this.nextToken(), c.prec = d, h.push(c), e.push(this.lookahead), h.push(this.isolateCoverGrammar(this.parseExponentiationExpression)) } var l = h.length - 1; for (b = h[l], e.pop() ; l > 1;) { var k = this.startNode(e.pop()); b = this.finalize(k, new j.BinaryExpression(h[l - 1].value, h[l - 2], b)), l -= 2 } } return b }, a.prototype.parseConditionalExpression = function () { var a = this.lookahead, b = this.inheritCoverGrammar(this.parseBinaryExpression); if (this.match("?")) { this.nextToken(); var c = this.context.allowIn; this.context.allowIn = !0; var d = this.isolateCoverGrammar(this.parseAssignmentExpression); this.context.allowIn = c, this.expect(":"); var e = this.isolateCoverGrammar(this.parseAssignmentExpression); b = this.finalize(this.startNode(a), new j.ConditionalExpression(b, d, e)), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1 } return b }, a.prototype.checkPatternParam = function (a, b) {
				switch (b.type) {
					case i.Syntax.Identifier: this.validateParam(a, b, b.name); break; case i.Syntax.RestElement: this.checkPatternParam(a, b.argument); break; case i.Syntax.AssignmentPattern: this.checkPatternParam(a, b.left); break; case i.Syntax.ArrayPattern: for (var c = 0; c < b.elements.length; c++) null !== b.elements[c] && this.checkPatternParam(a, b.elements[c]);
						break; case i.Syntax.YieldExpression: break; default: d.assert(b.type === i.Syntax.ObjectPattern, "Invalid type"); for (var c = 0; c < b.properties.length; c++) this.checkPatternParam(a, b.properties[c].value)
				}
			}, a.prototype.reinterpretAsCoverFormalsList = function (a) { var c, b = [a]; switch (a.type) { case i.Syntax.Identifier: break; case k: b = a.params; break; default: return null } c = { paramSet: {} }; for (var d = 0; d < b.length; ++d) { var f = b[d]; f.type === i.Syntax.AssignmentPattern && f.right.type === i.Syntax.YieldExpression && (f.right.argument && this.throwUnexpectedToken(this.lookahead), f.right.type = i.Syntax.Identifier, f.right.name = "yield", delete f.right.argument, delete f.right.delegate), this.checkPatternParam(c, f), b[d] = f } if (this.context.strict || !this.context.allowYield) for (var d = 0; d < b.length; ++d) { var f = b[d]; f.type === i.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead) } if (c.message === e.Messages.StrictParamDupe) { var g = this.context.strict ? c.stricted : c.firstRestricted; this.throwUnexpectedToken(g, c.message) } return { params: b, stricted: c.stricted, firstRestricted: c.firstRestricted, message: c.message } }, a.prototype.parseAssignmentExpression = function () { var a; if (!this.context.allowYield && this.matchKeyword("yield")) a = this.parseYieldExpression(); else { var b = this.lookahead, c = b; if (a = this.parseConditionalExpression(), a.type === k || this.match("=>")) { this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1; var d = this.reinterpretAsCoverFormalsList(a); if (d) { this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null; var f = this.context.strict, g = this.context.allowYield; this.context.allowYield = !0; var h = this.startNode(b); this.expect("=>"); var l = this.match("{") ? this.parseFunctionSourceElements() : this.isolateCoverGrammar(this.parseAssignmentExpression), m = l.type !== i.Syntax.BlockStatement; this.context.strict && d.firstRestricted && this.throwUnexpectedToken(d.firstRestricted, d.message), this.context.strict && d.stricted && this.tolerateUnexpectedToken(d.stricted, d.message), a = this.finalize(h, new j.ArrowFunctionExpression(d.params, l, m)), this.context.strict = f, this.context.allowYield = g } } else if (this.matchAssign()) { if (this.context.isAssignmentTarget || this.tolerateError(e.Messages.InvalidLHSInAssignment), this.context.strict && a.type === i.Syntax.Identifier) { var n = a; this.scanner.isRestrictedWord(n.name) && this.tolerateUnexpectedToken(c, e.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(n.name) && this.tolerateUnexpectedToken(c, e.Messages.StrictReservedWord) } this.match("=") ? this.reinterpretExpressionAsPattern(a) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1), c = this.nextToken(); var o = this.isolateCoverGrammar(this.parseAssignmentExpression); a = this.finalize(this.startNode(b), new j.AssignmentExpression(c.value, a, o)), this.context.firstCoverInitializedNameError = null } } return a }, a.prototype.parseExpression = function () { var a = this.lookahead, b = this.isolateCoverGrammar(this.parseAssignmentExpression); if (this.match(",")) { var c = []; for (c.push(b) ; this.startMarker.index < this.scanner.length && this.match(",") ;) this.nextToken(), c.push(this.isolateCoverGrammar(this.parseAssignmentExpression)); b = this.finalize(this.startNode(a), new j.SequenceExpression(c)) } return b }, a.prototype.parseStatementListItem = function () { var a = null; if (this.lookahead.type === g.Token.Keyword) switch (this.lookahead.value) { case "export": "module" !== this.sourceType && this.tolerateUnexpectedToken(this.lookahead, e.Messages.IllegalExportDeclaration), a = this.parseExportDeclaration(); break; case "import": "module" !== this.sourceType && this.tolerateUnexpectedToken(this.lookahead, e.Messages.IllegalImportDeclaration), a = this.parseImportDeclaration(); break; case "const": a = this.parseLexicalDeclaration({ inFor: !1 }); break; case "function": a = this.parseFunctionDeclaration(); break; case "class": a = this.parseClassDeclaration(); break; case "let": a = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement(); break; default: a = this.parseStatement() } else a = this.parseStatement(); return a }, a.prototype.parseBlock = function () { var a = this.createNode(); this.expect("{"); for (var b = []; ;) { if (this.match("}")) break; b.push(this.parseStatementListItem()) } return this.expect("}"), this.finalize(a, new j.BlockStatement(b)) }, a.prototype.parseLexicalBinding = function (a, b) { var c = this.createNode(), d = [], f = this.parsePattern(d, a); this.context.strict && f.type === i.Syntax.Identifier && this.scanner.isRestrictedWord(f.name) && this.tolerateError(e.Messages.StrictVarName); var g = null; return "const" === a ? this.matchKeyword("in") || this.matchContextualKeyword("of") || (this.expect("="), g = this.isolateCoverGrammar(this.parseAssignmentExpression)) : (!b.inFor && f.type !== i.Syntax.Identifier || this.match("=")) && (this.expect("="), g = this.isolateCoverGrammar(this.parseAssignmentExpression)), this.finalize(c, new j.VariableDeclarator(f, g)) }, a.prototype.parseBindingList = function (a, b) { for (var c = [this.parseLexicalBinding(a, b)]; this.match(",") ;) this.nextToken(), c.push(this.parseLexicalBinding(a, b)); return c }, a.prototype.isLexicalDeclaration = function () { var a = this.scanner.index, b = this.scanner.lineNumber, c = this.scanner.lineStart; this.collectComments(); var d = this.scanner.lex(); return this.scanner.index = a, this.scanner.lineNumber = b, this.scanner.lineStart = c, d.type === g.Token.Identifier || d.type === g.Token.Punctuator && "[" === d.value || d.type === g.Token.Punctuator && "{" === d.value || d.type === g.Token.Keyword && "let" === d.value || d.type === g.Token.Keyword && "yield" === d.value }, a.prototype.parseLexicalDeclaration = function (a) { var b = this.createNode(), c = this.nextToken().value; d.assert("let" === c || "const" === c, "Lexical declaration must be either let or const"); var e = this.parseBindingList(c, a); return this.consumeSemicolon(), this.finalize(b, new j.VariableDeclaration(e, c)) }, a.prototype.parseBindingRestElement = function (a, b) { var c = this.createNode(); this.expect("..."), a.push(this.lookahead); var d = this.parseVariableIdentifier(b); return this.finalize(c, new j.RestElement(d)) }, a.prototype.parseArrayPattern = function (a, b) { var c = this.createNode(); this.expect("["); for (var d = []; !this.match("]") ;) if (this.match(",")) this.nextToken(), d.push(null); else { if (this.match("...")) { d.push(this.parseBindingRestElement(a, b)); break } d.push(this.parsePatternWithDefault(a, b)), this.match("]") || this.expect(",") } return this.expect("]"), this.finalize(c, new j.ArrayPattern(d)) }, a.prototype.parsePropertyPattern = function (a, b) { var h, i, c = this.createNode(), d = !1, e = !1, f = !1; if (this.lookahead.type === g.Token.Identifier) { var k = this.lookahead; h = this.parseVariableIdentifier(); var l = this.finalize(c, new j.Identifier(k.value)); if (this.match("=")) { a.push(k), e = !0, this.nextToken(); var m = this.parseAssignmentExpression(); i = this.finalize(this.startNode(k), new j.AssignmentPattern(l, m)) } else this.match(":") ? (this.expect(":"), i = this.parsePatternWithDefault(a, b)) : (a.push(k), e = !0, i = l) } else d = this.match("["), h = this.parseObjectPropertyKey(), this.expect(":"), i = this.parsePatternWithDefault(a, b); return this.finalize(c, new j.Property("init", h, d, i, f, e)) }, a.prototype.parseObjectPattern = function (a, b) { var c = this.createNode(), d = []; for (this.expect("{") ; !this.match("}") ;) d.push(this.parsePropertyPattern(a, b)), this.match("}") || this.expect(","); return this.expect("}"), this.finalize(c, new j.ObjectPattern(d)) }, a.prototype.parsePattern = function (a, b) { var c; return this.match("[") ? c = this.parseArrayPattern(a, b) : this.match("{") ? c = this.parseObjectPattern(a, b) : (!this.matchKeyword("let") || "const" !== b && "let" !== b || this.tolerateUnexpectedToken(this.lookahead, e.Messages.UnexpectedToken), a.push(this.lookahead), c = this.parseVariableIdentifier(b)), c }, a.prototype.parsePatternWithDefault = function (a, b) { var c = this.lookahead, d = this.parsePattern(a, b); if (this.match("=")) { this.nextToken(); var e = this.context.allowYield; this.context.allowYield = !0; var f = this.isolateCoverGrammar(this.parseAssignmentExpression); this.context.allowYield = e, d = this.finalize(this.startNode(c), new j.AssignmentPattern(d, f)) } return d }, a.prototype.parseVariableIdentifier = function (a) { var b = this.createNode(), c = this.nextToken(); return c.type === g.Token.Keyword && "yield" === c.value ? (this.context.strict && this.tolerateUnexpectedToken(c, e.Messages.StrictReservedWord), this.context.allowYield || this.throwUnexpectedToken(c)) : c.type !== g.Token.Identifier ? this.context.strict && c.type === g.Token.Keyword && this.scanner.isStrictModeReservedWord(c.value) ? this.tolerateUnexpectedToken(c, e.Messages.StrictReservedWord) : (this.context.strict || "let" !== c.value || "var" !== a) && this.throwUnexpectedToken(c) : "module" === this.sourceType && c.type === g.Token.Identifier && "await" === c.value && this.tolerateUnexpectedToken(c), this.finalize(b, new j.Identifier(c.value)) }, a.prototype.parseVariableDeclaration = function (a) { var b = this.createNode(), c = [], d = this.parsePattern(c, "var"); this.context.strict && d.type === i.Syntax.Identifier && this.scanner.isRestrictedWord(d.name) && this.tolerateError(e.Messages.StrictVarName); var f = null; return this.match("=") ? (this.nextToken(), f = this.isolateCoverGrammar(this.parseAssignmentExpression)) : d.type === i.Syntax.Identifier || a.inFor || this.expect("="), this.finalize(b, new j.VariableDeclarator(d, f)) }, a.prototype.parseVariableDeclarationList = function (a) { var b = { inFor: a.inFor }, c = []; for (c.push(this.parseVariableDeclaration(b)) ; this.match(",") ;) this.nextToken(), c.push(this.parseVariableDeclaration(b)); return c }, a.prototype.parseVariableStatement = function () { var a = this.createNode(); this.expectKeyword("var"); var b = this.parseVariableDeclarationList({ inFor: !1 }); return this.consumeSemicolon(), this.finalize(a, new j.VariableDeclaration(b, "var")) }, a.prototype.parseEmptyStatement = function () { var a = this.createNode(); return this.expect(";"), this.finalize(a, new j.EmptyStatement) }, a.prototype.parseExpressionStatement = function () { var a = this.createNode(), b = this.parseExpression(); return this.consumeSemicolon(), this.finalize(a, new j.ExpressionStatement(b)) }, a.prototype.parseIfStatement = function () { var b, a = this.createNode(), c = null; this.expectKeyword("if"), this.expect("("); var d = this.parseExpression(); return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), b = this.finalize(this.createNode(), new j.EmptyStatement)) : (this.expect(")"), b = this.parseStatement(), this.matchKeyword("else") && (this.nextToken(), c = this.parseStatement())), this.finalize(a, new j.IfStatement(d, b, c)) }, a.prototype.parseDoWhileStatement = function () { var a = this.createNode(); this.expectKeyword("do"); var b = this.context.inIteration; this.context.inIteration = !0; var c = this.parseStatement(); this.context.inIteration = b, this.expectKeyword("while"), this.expect("("); var d = this.parseExpression(); return this.expect(")"), this.match(";") && this.nextToken(), this.finalize(a, new j.DoWhileStatement(c, d)) }, a.prototype.parseWhileStatement = function () { var b, a = this.createNode(); this.expectKeyword("while"), this.expect("("); var c = this.parseExpression(); if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), b = this.finalize(this.createNode(), new j.EmptyStatement); else { this.expect(")"); var d = this.context.inIteration; this.context.inIteration = !0, b = this.parseStatement(), this.context.inIteration = d } return this.finalize(a, new j.WhileStatement(c, b)) }, a.prototype.parseForStatement = function () { var f, g, a = null, b = null, c = null, d = !0, h = this.createNode(); if (this.expectKeyword("for"), this.expect("("), this.match(";")) this.nextToken(); else if (this.matchKeyword("var")) { a = this.createNode(), this.nextToken(); var k = this.context.allowIn; this.context.allowIn = !1; var l = this.parseVariableDeclarationList({ inFor: !0 }); if (this.context.allowIn = k, 1 === l.length && this.matchKeyword("in")) { var m = l[0]; m.init && (m.id.type === i.Syntax.ArrayPattern || m.id.type === i.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(e.Messages.ForInOfLoopInitializer, "for-in"), a = this.finalize(a, new j.VariableDeclaration(l, "var")), this.nextToken(), f = a, g = this.parseExpression(), a = null } else 1 === l.length && null === l[0].init && this.matchContextualKeyword("of") ? (a = this.finalize(a, new j.VariableDeclaration(l, "var")), this.nextToken(), f = a, g = this.parseAssignmentExpression(), a = null, d = !1) : (a = this.finalize(a, new j.VariableDeclaration(l, "var")), this.expect(";")) } else if (this.matchKeyword("const") || this.matchKeyword("let")) { a = this.createNode(); var n = this.nextToken().value; if (this.context.strict || "in" !== this.lookahead.value) { var k = this.context.allowIn; this.context.allowIn = !1; var l = this.parseBindingList(n, { inFor: !0 }); this.context.allowIn = k, 1 === l.length && null === l[0].init && this.matchKeyword("in") ? (a = this.finalize(a, new j.VariableDeclaration(l, n)), this.nextToken(), f = a, g = this.parseExpression(), a = null) : 1 === l.length && null === l[0].init && this.matchContextualKeyword("of") ? (a = this.finalize(a, new j.VariableDeclaration(l, n)), this.nextToken(), f = a, g = this.parseAssignmentExpression(), a = null, d = !1) : (this.consumeSemicolon(), a = this.finalize(a, new j.VariableDeclaration(l, n))) } else a = this.finalize(a, new j.Identifier(n)), this.nextToken(), f = a, g = this.parseExpression(), a = null } else { var o = this.lookahead, k = this.context.allowIn; if (this.context.allowIn = !1, a = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = k, this.matchKeyword("in")) this.context.isAssignmentTarget && a.type !== i.Syntax.AssignmentExpression || this.tolerateError(e.Messages.InvalidLHSInForIn), this.nextToken(), this.reinterpretExpressionAsPattern(a), f = a, g = this.parseExpression(), a = null; else if (this.matchContextualKeyword("of")) this.context.isAssignmentTarget && a.type !== i.Syntax.AssignmentExpression || this.tolerateError(e.Messages.InvalidLHSInForLoop), this.nextToken(), this.reinterpretExpressionAsPattern(a), f = a, g = this.parseAssignmentExpression(), a = null, d = !1; else { if (this.match(",")) { for (var p = [a]; this.match(",") ;) this.nextToken(), p.push(this.isolateCoverGrammar(this.parseAssignmentExpression)); a = this.finalize(this.startNode(o), new j.SequenceExpression(p)) } this.expect(";") } } "undefined" == typeof f && (this.match(";") || (b = this.parseExpression()), this.expect(";"), this.match(")") || (c = this.parseExpression())); var q; if (!this.match(")") && this.config.tolerant) this.tolerateUnexpectedToken(this.nextToken()), q = this.finalize(this.createNode(), new j.EmptyStatement); else { this.expect(")"); var r = this.context.inIteration; this.context.inIteration = !0, q = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = r } return "undefined" == typeof f ? this.finalize(h, new j.ForStatement(a, b, c, q)) : d ? this.finalize(h, new j.ForInStatement(f, g, q)) : this.finalize(h, new j.ForOfStatement(f, g, q)) }, a.prototype.parseContinueStatement = function () { var a = this.createNode(); this.expectKeyword("continue"); var b = null; if (this.lookahead.type === g.Token.Identifier && !this.hasLineTerminator) { b = this.parseVariableIdentifier(); var c = "$" + b.name; Object.prototype.hasOwnProperty.call(this.context.labelSet, c) || this.throwError(e.Messages.UnknownLabel, b.name) } return this.consumeSemicolon(), null !== b || this.context.inIteration || this.throwError(e.Messages.IllegalContinue), this.finalize(a, new j.ContinueStatement(b)) }, a.prototype.parseBreakStatement = function () { var a = this.createNode(); this.expectKeyword("break"); var b = null; if (this.lookahead.type === g.Token.Identifier && !this.hasLineTerminator) { b = this.parseVariableIdentifier(); var c = "$" + b.name; Object.prototype.hasOwnProperty.call(this.context.labelSet, c) || this.throwError(e.Messages.UnknownLabel, b.name) } return this.consumeSemicolon(), null !== b || this.context.inIteration || this.context.inSwitch || this.throwError(e.Messages.IllegalBreak), this.finalize(a, new j.BreakStatement(b)) }, a.prototype.parseReturnStatement = function () { this.context.inFunctionBody || this.tolerateError(e.Messages.IllegalReturn); var a = this.createNode(); this.expectKeyword("return"); var b = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== g.Token.EOF, c = b ? this.parseExpression() : null; return this.consumeSemicolon(), this.finalize(a, new j.ReturnStatement(c)) }, a.prototype.parseWithStatement = function () { this.context.strict && this.tolerateError(e.Messages.StrictModeWith); var a = this.createNode(); this.expectKeyword("with"), this.expect("("); var b = this.parseExpression(); this.expect(")"); var c = this.parseStatement(); return this.finalize(a, new j.WithStatement(b, c)) }, a.prototype.parseSwitchCase = function () { var b, a = this.createNode(); this.matchKeyword("default") ? (this.nextToken(), b = null) : (this.expectKeyword("case"), b = this.parseExpression()), this.expect(":"); for (var c = []; ;) { if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) break; c.push(this.parseStatementListItem()) } return this.finalize(a, new j.SwitchCase(b, c)) }, a.prototype.parseSwitchStatement = function () { var a = this.createNode(); this.expectKeyword("switch"), this.expect("("); var b = this.parseExpression(); this.expect(")"); var c = this.context.inSwitch; this.context.inSwitch = !0; var d = [], f = !1; for (this.expect("{") ; ;) { if (this.match("}")) break; var g = this.parseSwitchCase(); null === g.test && (f && this.throwError(e.Messages.MultipleDefaultsInSwitch), f = !0), d.push(g) } return this.expect("}"), this.context.inSwitch = c, this.finalize(a, new j.SwitchStatement(b, d)) }, a.prototype.parseLabelledStatement = function () { var c, a = this.createNode(), b = this.parseExpression(); if (b.type === i.Syntax.Identifier && this.match(":")) { this.nextToken(); var d = b, f = "$" + d.name; Object.prototype.hasOwnProperty.call(this.context.labelSet, f) && this.throwError(e.Messages.Redeclaration, "Label", d.name), this.context.labelSet[f] = !0; var g = this.parseStatement(); delete this.context.labelSet[f], c = new j.LabeledStatement(d, g) } else this.consumeSemicolon(), c = new j.ExpressionStatement(b); return this.finalize(a, c) }, a.prototype.parseThrowStatement = function () { var a = this.createNode(); this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(e.Messages.NewlineAfterThrow); var b = this.parseExpression(); return this.consumeSemicolon(), this.finalize(a, new j.ThrowStatement(b)) }, a.prototype.parseCatchClause = function () { var a = this.createNode(); this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead); for (var b = [], c = this.parsePattern(b), d = {}, f = 0; f < b.length; f++) { var g = "$" + b[f].value; Object.prototype.hasOwnProperty.call(d, g) && this.tolerateError(e.Messages.DuplicateBinding, b[f].value), d[g] = !0 } this.context.strict && c.type === i.Syntax.Identifier && this.scanner.isRestrictedWord(c.name) && this.tolerateError(e.Messages.StrictCatchVariable), this.expect(")"); var h = this.parseBlock(); return this.finalize(a, new j.CatchClause(c, h)) }, a.prototype.parseFinallyClause = function () { return this.expectKeyword("finally"), this.parseBlock() }, a.prototype.parseTryStatement = function () { var a = this.createNode(); this.expectKeyword("try"); var b = this.parseBlock(), c = this.matchKeyword("catch") ? this.parseCatchClause() : null, d = this.matchKeyword("finally") ? this.parseFinallyClause() : null; return c || d || this.throwError(e.Messages.NoCatchOrFinally), this.finalize(a, new j.TryStatement(b, c, d)) }, a.prototype.parseDebuggerStatement = function () { var a = this.createNode(); return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(a, new j.DebuggerStatement) }, a.prototype.parseStatement = function () { this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0; var a = null; switch (this.lookahead.type) { case g.Token.BooleanLiteral: case g.Token.NullLiteral: case g.Token.NumericLiteral: case g.Token.StringLiteral: case g.Token.Template: case g.Token.RegularExpression: a = this.parseExpressionStatement(); break; case g.Token.Punctuator: var b = this.lookahead.value; a = "{" === b ? this.parseBlock() : "(" === b ? this.parseExpressionStatement() : ";" === b ? this.parseEmptyStatement() : this.parseExpressionStatement(); break; case g.Token.Identifier: a = this.parseLabelledStatement(); break; case g.Token.Keyword: switch (this.lookahead.value) { case "break": a = this.parseBreakStatement(); break; case "continue": a = this.parseContinueStatement(); break; case "debugger": a = this.parseDebuggerStatement(); break; case "do": a = this.parseDoWhileStatement(); break; case "for": a = this.parseForStatement(); break; case "function": a = this.parseFunctionDeclaration(); break; case "if": a = this.parseIfStatement(); break; case "return": a = this.parseReturnStatement(); break; case "switch": a = this.parseSwitchStatement(); break; case "throw": a = this.parseThrowStatement(); break; case "try": a = this.parseTryStatement(); break; case "var": a = this.parseVariableStatement(); break; case "while": a = this.parseWhileStatement(); break; case "with": a = this.parseWithStatement(); break; default: a = this.parseExpressionStatement() } break; default: this.throwUnexpectedToken(this.lookahead) } return a }, a.prototype.parseFunctionSourceElements = function () { var a = this.createNode(); this.expect("{"); var b = this.parseDirectivePrologues(), c = this.context.labelSet, d = this.context.inIteration, e = this.context.inSwitch, f = this.context.inFunctionBody; for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.startMarker.index < this.scanner.length && !this.match("}") ;) b.push(this.parseStatementListItem()); return this.expect("}"), this.context.labelSet = c, this.context.inIteration = d, this.context.inSwitch = e, this.context.inFunctionBody = f, this.finalize(a, new j.BlockStatement(b)) }, a.prototype.validateParam = function (a, b, c) { var d = "$" + c; this.context.strict ? (this.scanner.isRestrictedWord(c) && (a.stricted = b, a.message = e.Messages.StrictParamName), Object.prototype.hasOwnProperty.call(a.paramSet, d) && (a.stricted = b, a.message = e.Messages.StrictParamDupe)) : a.firstRestricted || (this.scanner.isRestrictedWord(c) ? (a.firstRestricted = b, a.message = e.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(c) ? (a.firstRestricted = b, a.message = e.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(a.paramSet, d) && (a.stricted = b, a.message = e.Messages.StrictParamDupe)), "function" == typeof Object.defineProperty ? Object.defineProperty(a.paramSet, d, { value: !0, enumerable: !0, writable: !0, configurable: !0 }) : a.paramSet[d] = !0 }, a.prototype.parseRestElement = function (a) { var b = this.createNode(); this.nextToken(), this.match("{") && this.throwError(e.Messages.ObjectPatternAsRestParameter), a.push(this.lookahead); var c = this.parseVariableIdentifier(); return this.match("=") && this.throwError(e.Messages.DefaultRestParameter), this.match(")") || this.throwError(e.Messages.ParameterAfterRestParameter), this.finalize(b, new j.RestElement(c)) }, a.prototype.parseFormalParameter = function (a) { var b, c = [], d = this.lookahead; if ("..." === d.value) return b = this.parseRestElement(c), this.validateParam(a, b.argument, b.argument.name), a.params.push(b), !1; b = this.parsePatternWithDefault(c); for (var e = 0; e < c.length; e++) this.validateParam(a, c[e], c[e].value); return a.params.push(b), !this.match(")") }, a.prototype.parseFormalParameters = function (a) { var b; if (b = { params: [], firstRestricted: a }, this.expect("("), !this.match(")")) for (b.paramSet = {}; this.startMarker.index < this.scanner.length && this.parseFormalParameter(b) ;) this.expect(","); return this.expect(")"), { params: b.params, stricted: b.stricted, firstRestricted: b.firstRestricted, message: b.message } }, a.prototype.parseFunctionDeclaration = function (a) { var b = this.createNode(); this.expectKeyword("function"); var c = this.match("*"); c && this.nextToken(); var d, f = null, g = null; if (!a || !this.match("(")) { var h = this.lookahead; f = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(h.value) && this.tolerateUnexpectedToken(h, e.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(h.value) ? (g = h, d = e.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(h.value) && (g = h, d = e.Messages.StrictReservedWord) } var i = this.context.allowYield; this.context.allowYield = !c; var k = this.parseFormalParameters(g), l = k.params, m = k.stricted; g = k.firstRestricted, k.message && (d = k.message); var n = this.context.strict, o = this.parseFunctionSourceElements(); return this.context.strict && g && this.throwUnexpectedToken(g, d), this.context.strict && m && this.tolerateUnexpectedToken(m, d), this.context.strict = n, this.context.allowYield = i, this.finalize(b, new j.FunctionDeclaration(f, l, o, c)) }, a.prototype.parseFunctionExpression = function () { var a = this.createNode(); this.expectKeyword("function"); var b = this.match("*"); b && this.nextToken(); var c, f, d = null, g = this.context.allowYield; if (this.context.allowYield = !b, !this.match("(")) { var h = this.lookahead; d = this.context.strict || b || !this.matchKeyword("yield") ? this.parseVariableIdentifier() : this.parseIdentifierName(), this.context.strict ? this.scanner.isRestrictedWord(h.value) && this.tolerateUnexpectedToken(h, e.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(h.value) ? (f = h, c = e.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(h.value) && (f = h, c = e.Messages.StrictReservedWord) } var i = this.parseFormalParameters(f), k = i.params, l = i.stricted; f = i.firstRestricted, i.message && (c = i.message); var m = this.context.strict, n = this.parseFunctionSourceElements(); return this.context.strict && f && this.throwUnexpectedToken(f, c), this.context.strict && l && this.tolerateUnexpectedToken(l, c), this.context.strict = m, this.context.allowYield = g, this.finalize(a, new j.FunctionExpression(d, k, n, b)) }, a.prototype.parseDirective = function () { var a = this.lookahead, b = null, c = this.createNode(), d = this.parseExpression(); return d.type === i.Syntax.Literal && (b = this.getTokenRaw(a).slice(1, -1)), this.consumeSemicolon(), this.finalize(c, b ? new j.Directive(d, b) : new j.ExpressionStatement(d)) }, a.prototype.parseDirectivePrologues = function () { for (var a = null, b = []; ;) { var c = this.lookahead; if (c.type !== g.Token.StringLiteral) break; var d = this.parseDirective(); b.push(d); var f = d.directive; if ("string" != typeof f) break; "use strict" === f ? (this.context.strict = !0, a && this.tolerateUnexpectedToken(a, e.Messages.StrictOctalLiteral)) : !a && c.octal && (a = c) } return b }, a.prototype.qualifiedPropertyName = function (a) { switch (a.type) { case g.Token.Identifier: case g.Token.StringLiteral: case g.Token.BooleanLiteral: case g.Token.NullLiteral: case g.Token.NumericLiteral: case g.Token.Keyword: return !0; case g.Token.Punctuator: return "[" === a.value } return !1 }, a.prototype.parseGetterMethod = function () { var a = this.createNode(); this.expect("("), this.expect(")"); var b = !1, c = { params: [], stricted: null, firstRestricted: null, message: null }, d = this.context.allowYield; this.context.allowYield = !1; var e = this.parsePropertyMethod(c); return this.context.allowYield = d, this.finalize(a, new j.FunctionExpression(null, c.params, e, b)) }, a.prototype.parseSetterMethod = function () { var a = this.createNode(), b = { params: [], firstRestricted: null, paramSet: {} }, c = !1, d = this.context.allowYield; this.context.allowYield = !1, this.expect("("), this.match(")") ? this.tolerateUnexpectedToken(this.lookahead) : this.parseFormalParameter(b), this.expect(")"); var e = this.parsePropertyMethod(b); return this.context.allowYield = d, this.finalize(a, new j.FunctionExpression(null, b.params, e, c)) }, a.prototype.parseGeneratorMethod = function () { var a = this.createNode(), b = !0, c = this.context.allowYield; this.context.allowYield = !0; var d = this.parseFormalParameters(); this.context.allowYield = !1; var e = this.parsePropertyMethod(d); return this.context.allowYield = c, this.finalize(a, new j.FunctionExpression(null, d.params, e, b)) }, a.prototype.parseYieldExpression = function () { var a = this.createNode(); this.expectKeyword("yield"); var b = null, c = !1; if (!this.hasLineTerminator) { var d = this.context.allowYield; this.context.allowYield = !1, c = this.match("*"), c ? (this.nextToken(), b = this.parseAssignmentExpression()) : this.match(";") || this.match("}") || this.match(")") || this.lookahead.type === g.Token.EOF || (b = this.parseAssignmentExpression()), this.context.allowYield = d } return this.finalize(a, new j.YieldExpression(b, c)) }, a.prototype.parseClassElement = function (a) { var d, f, h, b = this.lookahead, c = this.createNode(), i = !1, k = !1, l = !1; if (this.match("*")) this.nextToken(); else { i = this.match("["), f = this.parseObjectPropertyKey(); var m = f; "static" === m.name && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (b = this.lookahead, l = !0, i = this.match("["), this.match("*") ? this.nextToken() : f = this.parseObjectPropertyKey()) } var n = this.qualifiedPropertyName(this.lookahead); return b.type === g.Token.Identifier ? "get" === b.value && n ? (d = "get", i = this.match("["), f = this.parseObjectPropertyKey(), this.context.allowYield = !1, h = this.parseGetterMethod()) : "set" === b.value && n && (d = "set", i = this.match("["), f = this.parseObjectPropertyKey(), h = this.parseSetterMethod()) : b.type === g.Token.Punctuator && "*" === b.value && n && (d = "init", i = this.match("["), f = this.parseObjectPropertyKey(), h = this.parseGeneratorMethod(), k = !0), !d && f && this.match("(") && (d = "init", h = this.parsePropertyMethodFunction(), k = !0), d || this.throwUnexpectedToken(this.lookahead), "init" === d && (d = "method"), i || (l && this.isPropertyKey(f, "prototype") && this.throwUnexpectedToken(b, e.Messages.StaticPrototype), !l && this.isPropertyKey(f, "constructor") && ("method" === d && k && !h.generator || this.throwUnexpectedToken(b, e.Messages.ConstructorSpecialMethod), a.value ? this.throwUnexpectedToken(b, e.Messages.DuplicateConstructor) : a.value = !0, d = "constructor")), this.finalize(c, new j.MethodDefinition(f, i, h, d, l)) }, a.prototype.parseClassElementList = function () { var a = [], b = { value: !1 }; for (this.expect("{") ; !this.match("}") ;) this.match(";") ? this.nextToken() : a.push(this.parseClassElement(b)); return this.expect("}"), a }, a.prototype.parseClassBody = function () { var a = this.createNode(), b = this.parseClassElementList(); return this.finalize(a, new j.ClassBody(b)) }, a.prototype.parseClassDeclaration = function (a) { var b = this.createNode(), c = this.context.strict; this.context.strict = !0, this.expectKeyword("class"); var d = a && this.lookahead.type !== g.Token.Identifier ? null : this.parseVariableIdentifier(), e = null; this.matchKeyword("extends") && (this.nextToken(), e = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall)); var f = this.parseClassBody(); return this.context.strict = c, this.finalize(b, new j.ClassDeclaration(d, e, f)) }, a.prototype.parseClassExpression = function () { var a = this.createNode(), b = this.context.strict; this.context.strict = !0, this.expectKeyword("class"); var c = this.lookahead.type === g.Token.Identifier ? this.parseVariableIdentifier() : null, d = null; this.matchKeyword("extends") && (this.nextToken(), d = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall)); var e = this.parseClassBody(); return this.context.strict = b, this.finalize(a, new j.ClassExpression(c, d, e)) }, a.prototype.parseProgram = function () { for (var a = this.createNode(), b = this.parseDirectivePrologues() ; this.startMarker.index < this.scanner.length;) b.push(this.parseStatementListItem()); return this.finalize(a, new j.Program(b, this.sourceType)) }, a.prototype.parseModuleSpecifier = function () { var a = this.createNode(); this.lookahead.type !== g.Token.StringLiteral && this.throwError(e.Messages.InvalidModuleSpecifier); var b = this.nextToken(), c = this.getTokenRaw(b); return this.finalize(a, new j.Literal(b.value, c)) }, a.prototype.parseImportSpecifier = function () { var b, a = this.createNode(), c = this.parseIdentifierName(); return this.matchContextualKeyword("as") ? (this.nextToken(), b = this.parseVariableIdentifier()) : b = c, this.finalize(a, new j.ImportSpecifier(b, c)) }, a.prototype.parseNamedImports = function () { this.expect("{"); for (var a = []; !this.match("}") ;) a.push(this.parseImportSpecifier()), this.match("}") || this.expect(","); return this.expect("}"), a }, a.prototype.parseImportDefaultSpecifier = function () { var a = this.createNode(), b = this.parseIdentifierName(); return this.finalize(a, new j.ImportDefaultSpecifier(b)) }, a.prototype.parseImportNamespaceSpecifier = function () { var a = this.createNode(); this.expect("*"), this.matchContextualKeyword("as") || this.throwError(e.Messages.NoAsAfterImportNamespace), this.nextToken(); var b = this.parseIdentifierName(); return this.finalize(a, new j.ImportNamespaceSpecifier(b)) }, a.prototype.parseImportDeclaration = function () {
				this.context.inFunctionBody && this.throwError(e.Messages.IllegalImportDeclaration); var a = this.createNode(); this.expectKeyword("import"); var b, c = []; if (this.lookahead.type === g.Token.StringLiteral) b = this.parseModuleSpecifier(); else {
					if (this.match("{") ? c = c.concat(this.parseNamedImports()) : this.match("*") ? c.push(this.parseImportNamespaceSpecifier()) : this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (c.push(this.parseImportDefaultSpecifier()), this.match(",") && (this.nextToken(), this.match("*") ? c.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? c = c.concat(this.parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword("from")) {
						var d = this.lookahead.value ? e.Messages.UnexpectedToken : e.Messages.MissingFromClause; this.throwError(d, this.lookahead.value)
					} this.nextToken(), b = this.parseModuleSpecifier()
				} return this.consumeSemicolon(), this.finalize(a, new j.ImportDeclaration(c, b))
			}, a.prototype.parseExportSpecifier = function () { var a = this.createNode(), b = this.parseIdentifierName(), c = b; return this.matchContextualKeyword("as") && (this.nextToken(), c = this.parseIdentifierName()), this.finalize(a, new j.ExportSpecifier(b, c)) }, a.prototype.parseExportDeclaration = function () { this.context.inFunctionBody && this.throwError(e.Messages.IllegalExportDeclaration); var a = this.createNode(); this.expectKeyword("export"); var b; if (this.matchKeyword("default")) if (this.nextToken(), this.matchKeyword("function")) { var c = this.parseFunctionDeclaration(!0); b = this.finalize(a, new j.ExportDefaultDeclaration(c)) } else if (this.matchKeyword("class")) { var c = this.parseClassDeclaration(!0); b = this.finalize(a, new j.ExportDefaultDeclaration(c)) } else { this.matchContextualKeyword("from") && this.throwError(e.Messages.UnexpectedToken, this.lookahead.value); var c = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression(); this.consumeSemicolon(), b = this.finalize(a, new j.ExportDefaultDeclaration(c)) } else if (this.match("*")) { if (this.nextToken(), !this.matchContextualKeyword("from")) { var d = this.lookahead.value ? e.Messages.UnexpectedToken : e.Messages.MissingFromClause; this.throwError(d, this.lookahead.value) } this.nextToken(); var f = this.parseModuleSpecifier(); this.consumeSemicolon(), b = this.finalize(a, new j.ExportAllDeclaration(f)) } else if (this.lookahead.type === g.Token.Keyword) { var c = void 0; switch (this.lookahead.value) { case "let": case "const": c = this.parseLexicalDeclaration({ inFor: !1 }); break; case "var": case "class": case "function": c = this.parseStatementListItem(); break; default: this.throwUnexpectedToken(this.lookahead) } b = this.finalize(a, new j.ExportNamedDeclaration(c, [], null)) } else { var h = [], i = null, k = !1; for (this.expect("{") ; !this.match("}") ;) k = k || this.matchKeyword("default"), h.push(this.parseExportSpecifier()), this.match("}") || this.expect(","); if (this.expect("}"), this.matchContextualKeyword("from")) this.nextToken(), i = this.parseModuleSpecifier(), this.consumeSemicolon(); else if (k) { var d = this.lookahead.value ? e.Messages.UnexpectedToken : e.Messages.MissingFromClause; this.throwError(d, this.lookahead.value) } else this.consumeSemicolon(); b = this.finalize(a, new j.ExportNamedDeclaration(null, h, i)) } return b }, a
		}(); b.Parser = l
	}, function (a, b) { "use strict"; function c(a, b) { if (!a) throw new Error("ASSERT: " + b) } b.assert = c }, function (a, b) { "use strict"; b.Messages = { UnexpectedToken: "Unexpected token %0", UnexpectedTokenIllegal: "Unexpected token ILLEGAL", UnexpectedNumber: "Unexpected number", UnexpectedString: "Unexpected string", UnexpectedIdentifier: "Unexpected identifier", UnexpectedReserved: "Unexpected reserved word", UnexpectedTemplate: "Unexpected quasi %0", UnexpectedEOS: "Unexpected end of input", NewlineAfterThrow: "Illegal newline after throw", InvalidRegExp: "Invalid regular expression", UnterminatedRegExp: "Invalid regular expression: missing /", InvalidLHSInAssignment: "Invalid left-hand side in assignment", InvalidLHSInForIn: "Invalid left-hand side in for-in", InvalidLHSInForLoop: "Invalid left-hand side in for-loop", MultipleDefaultsInSwitch: "More than one default clause in switch statement", NoCatchOrFinally: "Missing catch or finally after try", UnknownLabel: "Undefined label '%0'", Redeclaration: "%0 '%1' has already been declared", IllegalContinue: "Illegal continue statement", IllegalBreak: "Illegal break statement", IllegalReturn: "Illegal return statement", StrictModeWith: "Strict mode code may not include a with statement", StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode", StrictVarName: "Variable name may not be eval or arguments in strict mode", StrictParamName: "Parameter name eval or arguments is not allowed in strict mode", StrictParamDupe: "Strict mode function may not have duplicate parameter names", StrictFunctionName: "Function name may not be eval or arguments in strict mode", StrictOctalLiteral: "Octal literals are not allowed in strict mode.", StrictDelete: "Delete of an unqualified identifier in strict mode.", StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode", StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode", StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode", StrictReservedWord: "Use of future reserved word in strict mode", TemplateOctalLiteral: "Octal literals are not allowed in template strings.", ParameterAfterRestParameter: "Rest parameter must be last formal parameter", DefaultRestParameter: "Unexpected token =", ObjectPatternAsRestParameter: "Unexpected token {", DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals", ConstructorSpecialMethod: "Class constructor may not be an accessor", DuplicateConstructor: "A class may only have one constructor", StaticPrototype: "Classes may not have static property named prototype", MissingFromClause: "Unexpected token", NoAsAfterImportNamespace: "Unexpected token", InvalidModuleSpecifier: "Unexpected token", IllegalImportDeclaration: "Unexpected token", IllegalExportDeclaration: "Unexpected token", DuplicateBinding: "Duplicate binding %0", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer" } }, function (a, b) { "use strict"; var c = function () { function a() { this.errors = [], this.tolerant = !1 } return a.prototype.recordError = function (a) { this.errors.push(a) }, a.prototype.tolerate = function (a) { if (!this.tolerant) throw a; this.recordError(a) }, a.prototype.constructError = function (a, b) { var c = new Error(a); try { throw c } catch (a) { Object.create && Object.defineProperty && (c = Object.create(a), Object.defineProperty(c, "column", { value: b })) } finally { return c } }, a.prototype.createError = function (a, b, c, d) { var e = "Line " + b + ": " + d, f = this.constructError(e, c); return f.index = a, f.lineNumber = b, f.description = d, f }, a.prototype.throwError = function (a, b, c, d) { throw this.createError(a, b, c, d) }, a.prototype.tolerateError = function (a, b, c, d) { var e = this.createError(a, b, c, d); if (!this.tolerant) throw e; this.recordError(e) }, a }(); b.ErrorHandler = c }, function (a, b) { "use strict"; !function (a) { a[a.BooleanLiteral = 1] = "BooleanLiteral", a[a.EOF = 2] = "EOF", a[a.Identifier = 3] = "Identifier", a[a.Keyword = 4] = "Keyword", a[a.NullLiteral = 5] = "NullLiteral", a[a.NumericLiteral = 6] = "NumericLiteral", a[a.Punctuator = 7] = "Punctuator", a[a.StringLiteral = 8] = "StringLiteral", a[a.RegularExpression = 9] = "RegularExpression", a[a.Template = 10] = "Template" }(b.Token || (b.Token = {})); var c = b.Token; b.TokenName = {}, b.TokenName[c.BooleanLiteral] = "Boolean", b.TokenName[c.EOF] = "<end>", b.TokenName[c.Identifier] = "Identifier", b.TokenName[c.Keyword] = "Keyword", b.TokenName[c.NullLiteral] = "Null", b.TokenName[c.NumericLiteral] = "Numeric", b.TokenName[c.Punctuator] = "Punctuator", b.TokenName[c.StringLiteral] = "String", b.TokenName[c.RegularExpression] = "RegularExpression", b.TokenName[c.Template] = "Template" }, function (a, b, c) { "use strict"; function h(a) { return "0123456789abcdef".indexOf(a.toLowerCase()) } function i(a) { return "01234567".indexOf(a) } var d = c(4), e = c(5), f = c(9), g = c(7), j = function () { function a(a, b) { this.source = a, this.errorHandler = b, this.trackComment = !1, this.length = a.length, this.index = 0, this.lineNumber = a.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [] } return a.prototype.eof = function () { return this.index >= this.length }, a.prototype.throwUnexpectedToken = function (a) { void 0 === a && (a = e.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, a) }, a.prototype.tolerateUnexpectedToken = function () { this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, e.Messages.UnexpectedTokenIllegal) }, a.prototype.skipSingleLineComment = function (a) { var b, c, d; for (this.trackComment && (b = [], c = this.index - a, d = { start: { line: this.lineNumber, column: this.index - this.lineStart - a }, end: {} }) ; !this.eof() ;) { var e = this.source.charCodeAt(this.index); if (++this.index, f.Character.isLineTerminator(e)) { if (this.trackComment) { d.end = { line: this.lineNumber, column: this.index - this.lineStart - 1 }; var g = { multiLine: !1, slice: [c + a, this.index - 1], range: [c, this.index - 1], loc: d }; b.push(g) } return 13 === e && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, b } } if (this.trackComment) { d.end = { line: this.lineNumber, column: this.index - this.lineStart }; var g = { multiLine: !1, slice: [c + a, this.index], range: [c, this.index], loc: d }; b.push(g) } return b }, a.prototype.skipMultiLineComment = function () { var a, b, c; for (this.trackComment && (a = [], b = this.index - 2, c = { start: { line: this.lineNumber, column: this.index - this.lineStart - 2 }, end: {} }) ; !this.eof() ;) { var d = this.source.charCodeAt(this.index); if (f.Character.isLineTerminator(d)) 13 === d && 10 === this.source.charCodeAt(this.index + 1) && ++this.index, ++this.lineNumber, ++this.index, this.lineStart = this.index; else if (42 === d) { if (47 === this.source.charCodeAt(this.index + 1)) { if (this.index += 2, this.trackComment) { c.end = { line: this.lineNumber, column: this.index - this.lineStart }; var e = { multiLine: !0, slice: [b + 2, this.index - 2], range: [b, this.index], loc: c }; a.push(e) } return a } ++this.index } else ++this.index } if (this.trackComment) { c.end = { line: this.lineNumber, column: this.index - this.lineStart }; var e = { multiLine: !0, slice: [b + 2, this.index], range: [b, this.index], loc: c }; a.push(e) } return this.tolerateUnexpectedToken(), a }, a.prototype.scanComments = function () { var a; this.trackComment && (a = []); for (var b = 0 === this.index; !this.eof() ;) { var c = this.source.charCodeAt(this.index); if (f.Character.isWhiteSpace(c))++this.index; else if (f.Character.isLineTerminator(c))++this.index, 13 === c && 10 === this.source.charCodeAt(this.index) && ++this.index, ++this.lineNumber, this.lineStart = this.index, b = !0; else if (47 === c) if (c = this.source.charCodeAt(this.index + 1), 47 === c) { this.index += 2; var d = this.skipSingleLineComment(2); this.trackComment && (a = a.concat(d)), b = !0 } else { if (42 !== c) break; this.index += 2; var d = this.skipMultiLineComment(); this.trackComment && (a = a.concat(d)) } else if (b && 45 === c) { if (45 !== this.source.charCodeAt(this.index + 1) || 62 !== this.source.charCodeAt(this.index + 2)) break; this.index += 3; var d = this.skipSingleLineComment(3); this.trackComment && (a = a.concat(d)) } else { if (60 !== c) break; if ("!--" !== this.source.slice(this.index + 1, this.index + 4)) break; this.index += 4; var d = this.skipSingleLineComment(4); this.trackComment && (a = a.concat(d)) } } return a }, a.prototype.isFutureReservedWord = function (a) { switch (a) { case "enum": case "export": case "import": case "super": return !0; default: return !1 } }, a.prototype.isStrictModeReservedWord = function (a) { switch (a) { case "implements": case "interface": case "package": case "private": case "protected": case "public": case "static": case "yield": case "let": return !0; default: return !1 } }, a.prototype.isRestrictedWord = function (a) { return "eval" === a || "arguments" === a }, a.prototype.isKeyword = function (a) { switch (a.length) { case 2: return "if" === a || "in" === a || "do" === a; case 3: return "var" === a || "for" === a || "new" === a || "try" === a || "let" === a; case 4: return "this" === a || "else" === a || "case" === a || "void" === a || "with" === a || "enum" === a; case 5: return "while" === a || "break" === a || "catch" === a || "throw" === a || "const" === a || "yield" === a || "class" === a || "super" === a; case 6: return "return" === a || "typeof" === a || "delete" === a || "switch" === a || "export" === a || "import" === a; case 7: return "default" === a || "finally" === a || "extends" === a; case 8: return "function" === a || "continue" === a || "debugger" === a; case 10: return "instanceof" === a; default: return !1 } }, a.prototype.codePointAt = function (a) { var b = this.source.charCodeAt(a); if (b >= 55296 && b <= 56319) { var c = this.source.charCodeAt(a + 1); if (c >= 56320 && c <= 57343) { var d = b; b = 1024 * (d - 55296) + c - 56320 + 65536 } } return b }, a.prototype.scanHexEscape = function (a) { for (var b = "u" === a ? 4 : 2, c = 0, d = 0; d < b; ++d) { if (this.eof() || !f.Character.isHexDigit(this.source.charCodeAt(this.index))) return ""; c = 16 * c + h(this.source[this.index++]) } return String.fromCharCode(c) }, a.prototype.scanUnicodeCodePointEscape = function () { var a = this.source[this.index], b = 0; for ("}" === a && this.throwUnexpectedToken() ; !this.eof() && (a = this.source[this.index++], f.Character.isHexDigit(a.charCodeAt(0))) ;) b = 16 * b + h(a); return (b > 1114111 || "}" !== a) && this.throwUnexpectedToken(), f.Character.fromCodePoint(b) }, a.prototype.getIdentifier = function () { for (var a = this.index++; !this.eof() ;) { var b = this.source.charCodeAt(this.index); if (92 === b) return this.index = a, this.getComplexIdentifier(); if (b >= 55296 && b < 57343) return this.index = a, this.getComplexIdentifier(); if (!f.Character.isIdentifierPart(b)) break; ++this.index } return this.source.slice(a, this.index) }, a.prototype.getComplexIdentifier = function () { var a = this.codePointAt(this.index), b = f.Character.fromCodePoint(a); this.index += b.length; var c; for (92 === a && (117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, c = this.scanUnicodeCodePointEscape()) : (c = this.scanHexEscape("u"), a = c.charCodeAt(0), c && "\\" !== c && f.Character.isIdentifierStart(a) || this.throwUnexpectedToken()), b = c) ; !this.eof() && (a = this.codePointAt(this.index), f.Character.isIdentifierPart(a)) ;) c = f.Character.fromCodePoint(a), b += c, this.index += c.length, 92 === a && (b = b.substr(0, b.length - 1), 117 !== this.source.charCodeAt(this.index) && this.throwUnexpectedToken(), ++this.index, "{" === this.source[this.index] ? (++this.index, c = this.scanUnicodeCodePointEscape()) : (c = this.scanHexEscape("u"), a = c.charCodeAt(0), c && "\\" !== c && f.Character.isIdentifierPart(a) || this.throwUnexpectedToken()), b += c); return b }, a.prototype.octalToDecimal = function (a) { var b = "0" !== a, c = i(a); return !this.eof() && f.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (b = !0, c = 8 * c + i(this.source[this.index++]), "0123".indexOf(a) >= 0 && !this.eof() && f.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (c = 8 * c + i(this.source[this.index++]))), { code: c, octal: b } }, a.prototype.scanIdentifier = function () { var a, b = this.index, c = 92 === this.source.charCodeAt(b) ? this.getComplexIdentifier() : this.getIdentifier(); return a = 1 === c.length ? g.Token.Identifier : this.isKeyword(c) ? g.Token.Keyword : "null" === c ? g.Token.NullLiteral : "true" === c || "false" === c ? g.Token.BooleanLiteral : g.Token.Identifier, { type: a, value: c, lineNumber: this.lineNumber, lineStart: this.lineStart, start: b, end: this.index } }, a.prototype.scanPunctuator = function () { var a = { type: g.Token.Punctuator, value: "", lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index }, b = this.source[this.index]; switch (b) { case "(": case "{": "{" === b && this.curlyStack.push("{"), ++this.index; break; case ".": ++this.index, "." === this.source[this.index] && "." === this.source[this.index + 1] && (this.index += 2, b = "..."); break; case "}": ++this.index, this.curlyStack.pop(); break; case ")": case ";": case ",": case "[": case "]": case ":": case "?": case "~": ++this.index; break; default: b = this.source.substr(this.index, 4), ">>>=" === b ? this.index += 4 : (b = b.substr(0, 3), "===" === b || "!==" === b || ">>>" === b || "<<=" === b || ">>=" === b || "**=" === b ? this.index += 3 : (b = b.substr(0, 2), "&&" === b || "||" === b || "==" === b || "!=" === b || "+=" === b || "-=" === b || "*=" === b || "/=" === b || "++" === b || "--" === b || "<<" === b || ">>" === b || "&=" === b || "|=" === b || "^=" === b || "%=" === b || "<=" === b || ">=" === b || "=>" === b || "**" === b ? this.index += 2 : (b = this.source[this.index], "<>=!+-*%&|^/".indexOf(b) >= 0 && ++this.index))) } return this.index === a.start && this.throwUnexpectedToken(), a.end = this.index, a.value = b, a }, a.prototype.scanHexLiteral = function (a) { for (var b = ""; !this.eof() && f.Character.isHexDigit(this.source.charCodeAt(this.index)) ;) b += this.source[this.index++]; return 0 === b.length && this.throwUnexpectedToken(), f.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: g.Token.NumericLiteral, value: parseInt("0x" + b, 16), lineNumber: this.lineNumber, lineStart: this.lineStart, start: a, end: this.index } }, a.prototype.scanBinaryLiteral = function (a) { for (var c, b = ""; !this.eof() && (c = this.source[this.index], "0" === c || "1" === c) ;) b += this.source[this.index++]; return 0 === b.length && this.throwUnexpectedToken(), this.eof() || (c = this.source.charCodeAt(this.index), (f.Character.isIdentifierStart(c) || f.Character.isDecimalDigit(c)) && this.throwUnexpectedToken()), { type: g.Token.NumericLiteral, value: parseInt(b, 2), lineNumber: this.lineNumber, lineStart: this.lineStart, start: a, end: this.index } }, a.prototype.scanOctalLiteral = function (a, b) { var c = "", d = !1; for (f.Character.isOctalDigit(a.charCodeAt(0)) ? (d = !0, c = "0" + this.source[this.index++]) : ++this.index; !this.eof() && f.Character.isOctalDigit(this.source.charCodeAt(this.index)) ;) c += this.source[this.index++]; return d || 0 !== c.length || this.throwUnexpectedToken(), (f.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || f.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), { type: g.Token.NumericLiteral, value: parseInt(c, 8), octal: d, lineNumber: this.lineNumber, lineStart: this.lineStart, start: b, end: this.index } }, a.prototype.isImplicitOctalLiteral = function () { for (var a = this.index + 1; a < this.length; ++a) { var b = this.source[a]; if ("8" === b || "9" === b) return !1; if (!f.Character.isOctalDigit(b.charCodeAt(0))) return !0 } return !0 }, a.prototype.scanNumericLiteral = function () { var a = this.index, b = this.source[a]; d.assert(f.Character.isDecimalDigit(b.charCodeAt(0)) || "." === b, "Numeric literal must start with a decimal digit or a decimal point"); var c = ""; if ("." !== b) { if (c = this.source[this.index++], b = this.source[this.index], "0" === c) { if ("x" === b || "X" === b) return ++this.index, this.scanHexLiteral(a); if ("b" === b || "B" === b) return ++this.index, this.scanBinaryLiteral(a); if ("o" === b || "O" === b) return this.scanOctalLiteral(b, a); if (b && f.Character.isOctalDigit(b.charCodeAt(0)) && this.isImplicitOctalLiteral()) return this.scanOctalLiteral(b, a) } for (; f.Character.isDecimalDigit(this.source.charCodeAt(this.index)) ;) c += this.source[this.index++]; b = this.source[this.index] } if ("." === b) { for (c += this.source[this.index++]; f.Character.isDecimalDigit(this.source.charCodeAt(this.index)) ;) c += this.source[this.index++]; b = this.source[this.index] } if ("e" === b || "E" === b) if (c += this.source[this.index++], b = this.source[this.index], "+" !== b && "-" !== b || (c += this.source[this.index++]), f.Character.isDecimalDigit(this.source.charCodeAt(this.index))) for (; f.Character.isDecimalDigit(this.source.charCodeAt(this.index)) ;) c += this.source[this.index++]; else this.throwUnexpectedToken(); return f.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), { type: g.Token.NumericLiteral, value: parseFloat(c), lineNumber: this.lineNumber, lineStart: this.lineStart, start: a, end: this.index } }, a.prototype.scanStringLiteral = function () { var a = this.index, b = this.source[a]; d.assert("'" === b || '"' === b, "String literal must starts with a quote"), ++this.index; for (var c = !1, e = ""; !this.eof() ;) { var h = this.source[this.index++]; if (h === b) { b = ""; break } if ("\\" === h) if (h = this.source[this.index++], h && f.Character.isLineTerminator(h.charCodeAt(0)))++this.lineNumber, "\r" === h && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index; else switch (h) { case "u": case "x": if ("{" === this.source[this.index])++this.index, e += this.scanUnicodeCodePointEscape(); else { var i = this.scanHexEscape(h); i || this.throwUnexpectedToken(), e += i } break; case "n": e += "\n"; break; case "r": e += "\r"; break; case "t": e += "\t"; break; case "b": e += "\b"; break; case "f": e += "\f"; break; case "v": e += "\v"; break; case "8": case "9": e += h, this.tolerateUnexpectedToken(); break; default: if (h && f.Character.isOctalDigit(h.charCodeAt(0))) { var j = this.octalToDecimal(h); c = j.octal || c, e += String.fromCharCode(j.code) } else e += h } else { if (f.Character.isLineTerminator(h.charCodeAt(0))) break; e += h } } return "" !== b && (this.index = a, this.throwUnexpectedToken()), { type: g.Token.StringLiteral, value: e, octal: c, lineNumber: this.lineNumber, lineStart: this.lineStart, start: a, end: this.index } }, a.prototype.scanTemplate = function () { var a = "", b = !1, c = this.index, d = "`" === this.source[c], h = !1, i = 2; for (++this.index; !this.eof() ;) { var j = this.source[this.index++]; if ("`" === j) { i = 1, h = !0, b = !0; break } if ("$" === j) { if ("{" === this.source[this.index]) { this.curlyStack.push("${"), ++this.index, b = !0; break } a += j } else if ("\\" === j) if (j = this.source[this.index++], f.Character.isLineTerminator(j.charCodeAt(0)))++this.lineNumber, "\r" === j && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index; else switch (j) { case "n": a += "\n"; break; case "r": a += "\r"; break; case "t": a += "\t"; break; case "u": case "x": if ("{" === this.source[this.index])++this.index, a += this.scanUnicodeCodePointEscape(); else { var k = this.index, l = this.scanHexEscape(j); l ? a += l : (this.index = k, a += j) } break; case "b": a += "\b"; break; case "f": a += "\f"; break; case "v": a += "\v"; break; default: "0" === j ? (f.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(e.Messages.TemplateOctalLiteral), a += "\0") : f.Character.isOctalDigit(j.charCodeAt(0)) ? this.throwUnexpectedToken(e.Messages.TemplateOctalLiteral) : a += j } else f.Character.isLineTerminator(j.charCodeAt(0)) ? (++this.lineNumber, "\r" === j && "\n" === this.source[this.index] && ++this.index, this.lineStart = this.index, a += "\n") : a += j } return b || this.throwUnexpectedToken(), d || this.curlyStack.pop(), { type: g.Token.Template, value: { cooked: a, raw: this.source.slice(c + 1, this.index - i) }, head: d, tail: h, lineNumber: this.lineNumber, lineStart: this.lineStart, start: c, end: this.index } }, a.prototype.testRegExp = function (a, b) { var c = "￿", d = a, f = this; b.indexOf("u") >= 0 && (d = d.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function (a, b, d) { var g = parseInt(b || d, 16); return g > 1114111 && f.throwUnexpectedToken(e.Messages.InvalidRegExp), g <= 65535 ? String.fromCharCode(g) : c }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c)); try { RegExp(d) } catch (a) { this.throwUnexpectedToken(e.Messages.InvalidRegExp) } try { return new RegExp(a, b) } catch (a) { return null } }, a.prototype.scanRegExpBody = function () { var a = this.source[this.index]; d.assert("/" === a, "Regular expression literal must start with a slash"); for (var b = this.source[this.index++], c = !1, g = !1; !this.eof() ;) if (a = this.source[this.index++], b += a, "\\" === a) a = this.source[this.index++], f.Character.isLineTerminator(a.charCodeAt(0)) && this.throwUnexpectedToken(e.Messages.UnterminatedRegExp), b += a; else if (f.Character.isLineTerminator(a.charCodeAt(0))) this.throwUnexpectedToken(e.Messages.UnterminatedRegExp); else if (c) "]" === a && (c = !1); else { if ("/" === a) { g = !0; break } "[" === a && (c = !0) } g || this.throwUnexpectedToken(e.Messages.UnterminatedRegExp); var h = b.substr(1, b.length - 2); return { value: h, literal: b } }, a.prototype.scanRegExpFlags = function () { for (var a = "", b = ""; !this.eof() ;) { var c = this.source[this.index]; if (!f.Character.isIdentifierPart(c.charCodeAt(0))) break; if (++this.index, "\\" !== c || this.eof()) b += c, a += c; else if (c = this.source[this.index], "u" === c) { ++this.index; var d = this.index; if (c = this.scanHexEscape("u")) for (b += c, a += "\\u"; d < this.index; ++d) a += this.source[d]; else this.index = d, b += "u", a += "\\u"; this.tolerateUnexpectedToken() } else a += "\\", this.tolerateUnexpectedToken() } return { value: b, literal: a } }, a.prototype.scanRegExp = function () { var a = this.index, b = this.scanRegExpBody(), c = this.scanRegExpFlags(), d = this.testRegExp(b.value, c.value); return { type: g.Token.RegularExpression, value: d, literal: b.literal + c.literal, regex: { pattern: b.value, flags: c.value }, lineNumber: this.lineNumber, lineStart: this.lineStart, start: a, end: this.index } }, a.prototype.lex = function () { if (this.eof()) return { type: g.Token.EOF, lineNumber: this.lineNumber, lineStart: this.lineStart, start: this.index, end: this.index }; var a = this.source.charCodeAt(this.index); return f.Character.isIdentifierStart(a) ? this.scanIdentifier() : 40 === a || 41 === a || 59 === a ? this.scanPunctuator() : 39 === a || 34 === a ? this.scanStringLiteral() : 46 === a ? f.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.scanNumericLiteral() : this.scanPunctuator() : f.Character.isDecimalDigit(a) ? this.scanNumericLiteral() : 96 === a || 125 === a && "${" === this.curlyStack[this.curlyStack.length - 1] ? this.scanTemplate() : a >= 55296 && a < 57343 && f.Character.isIdentifierStart(this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator() }, a }(); b.Scanner = j }, function (a, b) {
		"use strict"; var c = {
			NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
		}; b.Character = { fromCodePoint: function (a) { return a < 65536 ? String.fromCharCode(a) : String.fromCharCode(55296 + (a - 65536 >> 10)) + String.fromCharCode(56320 + (a - 65536 & 1023)) }, isWhiteSpace: function (a) { return 32 === a || 9 === a || 11 === a || 12 === a || 160 === a || a >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(a) >= 0 }, isLineTerminator: function (a) { return 10 === a || 13 === a || 8232 === a || 8233 === a }, isIdentifierStart: function (a) { return 36 === a || 95 === a || a >= 65 && a <= 90 || a >= 97 && a <= 122 || 92 === a || a >= 128 && c.NonAsciiIdentifierStart.test(b.Character.fromCodePoint(a)) }, isIdentifierPart: function (a) { return 36 === a || 95 === a || a >= 65 && a <= 90 || a >= 97 && a <= 122 || a >= 48 && a <= 57 || 92 === a || a >= 128 && c.NonAsciiIdentifierPart.test(b.Character.fromCodePoint(a)) }, isDecimalDigit: function (a) { return a >= 48 && a <= 57 }, isHexDigit: function (a) { return a >= 48 && a <= 57 || a >= 65 && a <= 72 || a >= 97 && a <= 104 }, isOctalDigit: function (a) { return a >= 48 && a <= 55 } }
	}, function (a, b, c) { "use strict"; var d = c(2), e = function () { function a(a) { this.type = d.Syntax.ArrayExpression, this.elements = a } return a }(); b.ArrayExpression = e; var f = function () { function a(a) { this.type = d.Syntax.ArrayPattern, this.elements = a } return a }(); b.ArrayPattern = f; var g = function () { function a(a, b, c) { this.type = d.Syntax.ArrowFunctionExpression, this.id = null, this.params = a, this.body = b, this.generator = !1, this.expression = c } return a }(); b.ArrowFunctionExpression = g; var h = function () { function a(a, b, c) { this.type = d.Syntax.AssignmentExpression, this.operator = a, this.left = b, this.right = c } return a }(); b.AssignmentExpression = h; var i = function () { function a(a, b) { this.type = d.Syntax.AssignmentPattern, this.left = a, this.right = b } return a }(); b.AssignmentPattern = i; var j = function () { function a(a, b, c) { var e = "||" === a || "&&" === a; this.type = e ? d.Syntax.LogicalExpression : d.Syntax.BinaryExpression, this.operator = a, this.left = b, this.right = c } return a }(); b.BinaryExpression = j; var k = function () { function a(a) { this.type = d.Syntax.BlockStatement, this.body = a } return a }(); b.BlockStatement = k; var l = function () { function a(a) { this.type = d.Syntax.BreakStatement, this.label = a } return a }(); b.BreakStatement = l; var m = function () { function a(a, b) { this.type = d.Syntax.CallExpression, this.callee = a, this.arguments = b } return a }(); b.CallExpression = m; var n = function () { function a(a, b) { this.type = d.Syntax.CatchClause, this.param = a, this.body = b } return a }(); b.CatchClause = n; var o = function () { function a(a) { this.type = d.Syntax.ClassBody, this.body = a } return a }(); b.ClassBody = o; var p = function () { function a(a, b, c) { this.type = d.Syntax.ClassDeclaration, this.id = a, this.superClass = b, this.body = c } return a }(); b.ClassDeclaration = p; var q = function () { function a(a, b, c) { this.type = d.Syntax.ClassExpression, this.id = a, this.superClass = b, this.body = c } return a }(); b.ClassExpression = q; var r = function () { function a(a, b) { this.type = d.Syntax.MemberExpression, this.computed = !0, this.object = a, this.property = b } return a }(); b.ComputedMemberExpression = r; var s = function () { function a(a, b, c) { this.type = d.Syntax.ConditionalExpression, this.test = a, this.consequent = b, this.alternate = c } return a }(); b.ConditionalExpression = s; var t = function () { function a(a) { this.type = d.Syntax.ContinueStatement, this.label = a } return a }(); b.ContinueStatement = t; var u = function () { function a() { this.type = d.Syntax.DebuggerStatement } return a }(); b.DebuggerStatement = u; var v = function () { function a(a, b) { this.type = d.Syntax.ExpressionStatement, this.expression = a, this.directive = b } return a }(); b.Directive = v; var w = function () { function a(a, b) { this.type = d.Syntax.DoWhileStatement, this.body = a, this.test = b } return a }(); b.DoWhileStatement = w; var x = function () { function a() { this.type = d.Syntax.EmptyStatement } return a }(); b.EmptyStatement = x; var y = function () { function a(a) { this.type = d.Syntax.ExportAllDeclaration, this.source = a } return a }(); b.ExportAllDeclaration = y; var z = function () { function a(a) { this.type = d.Syntax.ExportDefaultDeclaration, this.declaration = a } return a }(); b.ExportDefaultDeclaration = z; var A = function () { function a(a, b, c) { this.type = d.Syntax.ExportNamedDeclaration, this.declaration = a, this.specifiers = b, this.source = c } return a }(); b.ExportNamedDeclaration = A; var B = function () { function a(a, b) { this.type = d.Syntax.ExportSpecifier, this.exported = b, this.local = a } return a }(); b.ExportSpecifier = B; var C = function () { function a(a) { this.type = d.Syntax.ExpressionStatement, this.expression = a } return a }(); b.ExpressionStatement = C; var D = function () { function a(a, b, c) { this.type = d.Syntax.ForInStatement, this.left = a, this.right = b, this.body = c, this.each = !1 } return a }(); b.ForInStatement = D; var E = function () { function a(a, b, c) { this.type = d.Syntax.ForOfStatement, this.left = a, this.right = b, this.body = c } return a }(); b.ForOfStatement = E; var F = function () { function a(a, b, c, e) { this.type = d.Syntax.ForStatement, this.init = a, this.test = b, this.update = c, this.body = e } return a }(); b.ForStatement = F; var G = function () { function a(a, b, c, e) { this.type = d.Syntax.FunctionDeclaration, this.id = a, this.params = b, this.body = c, this.generator = e, this.expression = !1 } return a }(); b.FunctionDeclaration = G; var H = function () { function a(a, b, c, e) { this.type = d.Syntax.FunctionExpression, this.id = a, this.params = b, this.body = c, this.generator = e, this.expression = !1 } return a }(); b.FunctionExpression = H; var I = function () { function a(a) { this.type = d.Syntax.Identifier, this.name = a } return a }(); b.Identifier = I; var J = function () { function a(a, b, c) { this.type = d.Syntax.IfStatement, this.test = a, this.consequent = b, this.alternate = c } return a }(); b.IfStatement = J; var K = function () { function a(a, b) { this.type = d.Syntax.ImportDeclaration, this.specifiers = a, this.source = b } return a }(); b.ImportDeclaration = K; var L = function () { function a(a) { this.type = d.Syntax.ImportDefaultSpecifier, this.local = a } return a }(); b.ImportDefaultSpecifier = L; var M = function () { function a(a) { this.type = d.Syntax.ImportNamespaceSpecifier, this.local = a } return a }(); b.ImportNamespaceSpecifier = M; var N = function () { function a(a, b) { this.type = d.Syntax.ImportSpecifier, this.local = a, this.imported = b } return a }(); b.ImportSpecifier = N; var O = function () { function a(a, b) { this.type = d.Syntax.LabeledStatement, this.label = a, this.body = b } return a }(); b.LabeledStatement = O; var P = function () { function a(a, b) { this.type = d.Syntax.Literal, this.value = a, this.raw = b } return a }(); b.Literal = P; var Q = function () { function a(a, b) { this.type = d.Syntax.MetaProperty, this.meta = a, this.property = b } return a }(); b.MetaProperty = Q; var R = function () { function a(a, b, c, e, f) { this.type = d.Syntax.MethodDefinition, this.key = a, this.computed = b, this.value = c, this.kind = e, this.static = f } return a }(); b.MethodDefinition = R; var S = function () { function a(a, b) { this.type = d.Syntax.NewExpression, this.callee = a, this.arguments = b } return a }(); b.NewExpression = S; var T = function () { function a(a) { this.type = d.Syntax.ObjectExpression, this.properties = a } return a }(); b.ObjectExpression = T; var U = function () { function a(a) { this.type = d.Syntax.ObjectPattern, this.properties = a } return a }(); b.ObjectPattern = U; var V = function () { function a(a, b) { this.type = d.Syntax.Program, this.body = a, this.sourceType = b } return a }(); b.Program = V; var W = function () { function a(a, b, c, e, f, g) { this.type = d.Syntax.Property, this.key = b, this.computed = c, this.value = e, this.kind = a, this.method = f, this.shorthand = g } return a }(); b.Property = W; var X = function () { function a(a, b, c) { this.type = d.Syntax.Literal, this.value = a, this.raw = b, this.regex = c } return a }(); b.RegexLiteral = X; var Y = function () { function a(a) { this.type = d.Syntax.RestElement, this.argument = a } return a }(); b.RestElement = Y; var Z = function () { function a(a) { this.type = d.Syntax.ReturnStatement, this.argument = a } return a }(); b.ReturnStatement = Z; var $ = function () { function a(a) { this.type = d.Syntax.SequenceExpression, this.expressions = a } return a }(); b.SequenceExpression = $; var _ = function () { function a(a) { this.type = d.Syntax.SpreadElement, this.argument = a } return a }(); b.SpreadElement = _; var aa = function () { function a(a, b) { this.type = d.Syntax.MemberExpression, this.computed = !1, this.object = a, this.property = b } return a }(); b.StaticMemberExpression = aa; var ba = function () { function a() { this.type = d.Syntax.Super } return a }(); b.Super = ba; var ca = function () { function a(a, b) { this.type = d.Syntax.SwitchCase, this.test = a, this.consequent = b } return a }(); b.SwitchCase = ca; var da = function () { function a(a, b) { this.type = d.Syntax.SwitchStatement, this.discriminant = a, this.cases = b } return a }(); b.SwitchStatement = da; var ea = function () { function a(a, b) { this.type = d.Syntax.TaggedTemplateExpression, this.tag = a, this.quasi = b } return a }(); b.TaggedTemplateExpression = ea; var fa = function () { function a(a, b) { this.type = d.Syntax.TemplateElement, this.value = a, this.tail = b } return a }(); b.TemplateElement = fa; var ga = function () { function a(a, b) { this.type = d.Syntax.TemplateLiteral, this.quasis = a, this.expressions = b } return a }(); b.TemplateLiteral = ga; var ha = function () { function a() { this.type = d.Syntax.ThisExpression } return a }(); b.ThisExpression = ha; var ia = function () { function a(a) { this.type = d.Syntax.ThrowStatement, this.argument = a } return a }(); b.ThrowStatement = ia; var ja = function () { function a(a, b, c) { this.type = d.Syntax.TryStatement, this.block = a, this.handler = b, this.finalizer = c } return a }(); b.TryStatement = ja; var ka = function () { function a(a, b) { this.type = d.Syntax.UnaryExpression, this.operator = a, this.argument = b, this.prefix = !0 } return a }(); b.UnaryExpression = ka; var la = function () { function a(a, b, c) { this.type = d.Syntax.UpdateExpression, this.operator = a, this.argument = b, this.prefix = c } return a }(); b.UpdateExpression = la; var ma = function () { function a(a, b) { this.type = d.Syntax.VariableDeclaration, this.declarations = a, this.kind = b } return a }(); b.VariableDeclaration = ma; var na = function () { function a(a, b) { this.type = d.Syntax.VariableDeclarator, this.id = a, this.init = b } return a }(); b.VariableDeclarator = na; var oa = function () { function a(a, b) { this.type = d.Syntax.WhileStatement, this.test = a, this.body = b } return a }(); b.WhileStatement = oa; var pa = function () { function a(a, b) { this.type = d.Syntax.WithStatement, this.object = a, this.body = b } return a }(); b.WithStatement = pa; var qa = function () { function a(a, b) { this.type = d.Syntax.YieldExpression, this.argument = a, this.delegate = b } return a }(); b.YieldExpression = qa }, function (a, b, c) { "use strict"; function m(a) { var b; switch (a.type) { case i.JSXSyntax.JSXIdentifier: var c = a; b = c.name; break; case i.JSXSyntax.JSXNamespacedName: var d = a; b = m(d.namespace) + ":" + m(d.name); break; case i.JSXSyntax.JSXMemberExpression: var e = a; b = m(e.object) + "." + m(e.property) } return b } var l, d = this && this.__extends || function (a, b) { function d() { this.constructor = a } for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]); a.prototype = null === b ? Object.create(b) : (d.prototype = b.prototype, new d) }, e = c(9), f = c(7), g = c(3), h = c(12), i = c(13), j = c(10), k = c(14); !function (a) { a[a.Identifier = 100] = "Identifier", a[a.Text = 101] = "Text" }(l || (l = {})), f.TokenName[l.Identifier] = "JSXIdentifier", f.TokenName[l.Text] = "JSXText"; var n = function (a) { function b(b, c, d) { a.call(this, b, c, d) } return d(b, a), b.prototype.parsePrimaryExpression = function () { return this.match("<") ? this.parseJSXRoot() : a.prototype.parsePrimaryExpression.call(this) }, b.prototype.startJSX = function () { this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.lineNumber, this.scanner.lineStart = this.startMarker.lineStart }, b.prototype.finishJSX = function () { this.nextToken() }, b.prototype.createJSXNode = function () { return this.collectComments(), { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }, b.prototype.createJSXChildNode = function () { return { index: this.scanner.index, line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart } }, b.prototype.scanXHTMLEntity = function () { for (var a = "&", b = ""; !this.scanner.eof() ;) { var c = this.scanner.source[this.scanner.index++]; if (";" === c) { if ("#" === b[0]) { b = b.substr(1); var d = "x" === b[0], e = d ? parseInt("0" + b, 16) : parseInt(b, 10); a = String.fromCharCode(e) } else h.XHTMLEntities[b] ? a = h.XHTMLEntities[b] : a += c; break } b += c, a += c } return a }, b.prototype.lexJSX = function () { var a = this.scanner.source.charCodeAt(this.scanner.index); if (60 === a || 62 === a || 47 === a || 58 === a || 61 === a || 123 === a || 125 === a) { var b = this.scanner.source[this.scanner.index++]; return { type: f.Token.Punctuator, value: b, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: this.scanner.index - 1, end: this.scanner.index } } if (34 === a || 39 === a) { for (var c = this.scanner.index, d = this.scanner.source[this.scanner.index++], g = ""; !this.scanner.eof() ;) { var h = this.scanner.source[this.scanner.index++]; if (h === d) break; g += "&" === h ? this.scanXHTMLEntity() : h } return { type: f.Token.StringLiteral, value: g, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: c, end: this.scanner.index } } if (46 === a) { var i = this.scanner.source.charCodeAt(this.scanner.index + 1), j = this.scanner.source.charCodeAt(this.scanner.index + 2), b = 46 === i && 46 === j ? "..." : ".", c = this.scanner.index; return this.scanner.index += b.length, { type: f.Token.Punctuator, value: b, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: c, end: this.scanner.index } } if (e.Character.isIdentifierStart(a) && 92 !== a) { var c = this.scanner.index; for (++this.scanner.index; !this.scanner.eof() ;) { var h = this.scanner.source.charCodeAt(this.scanner.index); if (e.Character.isIdentifierPart(h) && 92 !== h)++this.scanner.index; else { if (45 !== h) break; ++this.scanner.index } } var k = this.scanner.source.slice(c, this.scanner.index); return { type: l.Identifier, value: k, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: c, end: this.scanner.index } } this.scanner.throwUnexpectedToken() }, b.prototype.nextJSXToken = function () { this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.lineNumber = this.scanner.lineNumber, this.startMarker.lineStart = this.scanner.lineStart; var a = this.lexJSX(); return this.lastMarker.index = this.scanner.index, this.lastMarker.lineNumber = this.scanner.lineNumber, this.lastMarker.lineStart = this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(a)), a }, b.prototype.nextJSXText = function () { this.startMarker.index = this.scanner.index, this.startMarker.lineNumber = this.scanner.lineNumber, this.startMarker.lineStart = this.scanner.lineStart; for (var a = this.scanner.index, b = ""; !this.scanner.eof() ;) { var c = this.scanner.source[this.scanner.index]; if ("{" === c || "<" === c) break; ++this.scanner.index, b += c, e.Character.isLineTerminator(c.charCodeAt(0)) && (++this.scanner.lineNumber, "\r" === c && "\n" === this.scanner.source[this.scanner.index] && ++this.scanner.index, this.scanner.lineStart = this.scanner.index) } this.lastMarker.index = this.scanner.index, this.lastMarker.lineNumber = this.scanner.lineNumber, this.lastMarker.lineStart = this.scanner.lineStart; var d = { type: l.Text, value: b, lineNumber: this.scanner.lineNumber, lineStart: this.scanner.lineStart, start: a, end: this.scanner.index }; return b.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(d)), d }, b.prototype.peekJSXToken = function () { var a = this.scanner.index, b = this.scanner.lineNumber, c = this.scanner.lineStart; this.scanner.scanComments(); var d = this.lexJSX(); return this.scanner.index = a, this.scanner.lineNumber = b, this.scanner.lineStart = c, d }, b.prototype.expectJSX = function (a) { var b = this.nextJSXToken(); b.type === f.Token.Punctuator && b.value === a || this.throwUnexpectedToken(b) }, b.prototype.matchJSX = function (a) { var b = this.peekJSXToken(); return b.type === f.Token.Punctuator && b.value === a }, b.prototype.parseJSXIdentifier = function () { var a = this.createJSXNode(), b = this.nextJSXToken(); return b.type !== l.Identifier && this.throwUnexpectedToken(b), this.finalize(a, new k.JSXIdentifier(b.value)) }, b.prototype.parseJSXElementName = function () { var a = this.createJSXNode(), b = this.parseJSXIdentifier(); if (this.matchJSX(":")) { var c = b; this.expectJSX(":"); var d = this.parseJSXIdentifier(); b = this.finalize(a, new k.JSXNamespacedName(c, d)) } else if (this.matchJSX(".")) for (; this.matchJSX(".") ;) { var e = b; this.expectJSX("."); var f = this.parseJSXIdentifier(); b = this.finalize(a, new k.JSXMemberExpression(e, f)) } return b }, b.prototype.parseJSXAttributeName = function () { var b, a = this.createJSXNode(), c = this.parseJSXIdentifier(); if (this.matchJSX(":")) { var d = c; this.expectJSX(":"); var e = this.parseJSXIdentifier(); b = this.finalize(a, new k.JSXNamespacedName(d, e)) } else b = c; return b }, b.prototype.parseJSXStringLiteralAttribute = function () { var a = this.createJSXNode(), b = this.nextJSXToken(); b.type !== f.Token.StringLiteral && this.throwUnexpectedToken(b); var c = this.getTokenRaw(b); return this.finalize(a, new j.Literal(b.value, c)) }, b.prototype.parseJSXExpressionAttribute = function () { var a = this.createJSXNode(); this.expectJSX("{"); var b = null; return this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty expression"), b = this.parseAssignmentExpression(), this.startJSX(), this.expectJSX("}"), this.finalize(a, new k.JSXExpressionContainer(b)) }, b.prototype.parseJSXAttributeValue = function () { return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute() }, b.prototype.parseJSXNameValueAttribute = function () { var a = this.createJSXNode(), b = this.parseJSXAttributeName(), c = null; return this.matchJSX("=") && (this.expectJSX("="), c = this.parseJSXAttributeValue()), this.finalize(a, new k.JSXAttribute(b, c)) }, b.prototype.parseJSXSpreadAttribute = function () { var a = this.createJSXNode(); this.expectJSX("{"), this.expectJSX("..."), this.finishJSX(); var b = this.parseAssignmentExpression(); return this.startJSX(), this.expectJSX("}"), this.finalize(a, new k.JSXSpreadAttribute(b)) }, b.prototype.parseJSXAttributes = function () { for (var a = []; !this.matchJSX("/") && !this.matchJSX(">") ;) { var b = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute(); a.push(b) } return a }, b.prototype.parseJSXOpeningElement = function () { var a = this.createJSXNode(); this.expectJSX("<"); var b = this.parseJSXElementName(), c = this.parseJSXAttributes(), d = this.matchJSX("/"); return d && this.expectJSX("/"), this.expectJSX(">"), this.finalize(a, new k.JSXOpeningElement(b, d, c)) }, b.prototype.parseJSXBoundaryElement = function () { var a = this.createJSXNode(); if (this.expectJSX("<"), this.matchJSX("/")) { this.expectJSX("/"); var b = this.parseJSXElementName(); return this.expectJSX(">"), this.finalize(a, new k.JSXClosingElement(b)) } var c = this.parseJSXElementName(), d = this.parseJSXAttributes(), e = this.matchJSX("/"); return e && this.expectJSX("/"), this.expectJSX(">"), this.finalize(a, new k.JSXOpeningElement(c, e, d)) }, b.prototype.parseJSXEmptyExpression = function () { var a = this.createJSXChildNode(); return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.lineNumber = this.scanner.lineNumber, this.lastMarker.lineStart = this.scanner.lineStart, this.finalize(a, new k.JSXEmptyExpression) }, b.prototype.parseJSXExpression = function () { var a; return this.matchJSX("}") ? a = this.parseJSXEmptyExpression() : (this.finishJSX(), a = this.parseAssignmentExpression(), this.startJSX()), a }, b.prototype.parseJSXExpressionContainer = function () { var a = this.createJSXNode(); this.expectJSX("{"); var b = this.parseJSXExpression(); return this.expectJSX("}"), this.finalize(a, new k.JSXExpressionContainer(b)) }, b.prototype.parseJSXChildren = function () { for (var a = []; !this.scanner.eof() ;) { var b = this.createJSXChildNode(), c = this.nextJSXText(); if (c.start < c.end) { var d = this.getTokenRaw(c), e = this.finalize(b, new k.JSXText(c.value, d)); a.push(e) } if ("{" !== this.scanner.source[this.scanner.index]) break; var f = this.parseJSXExpressionContainer(); a.push(f) } return a }, b.prototype.parseComplexJSXElement = function (a) { for (var b = []; !this.scanner.eof() ;) { a.children = a.children.concat(this.parseJSXChildren()); var c = this.createJSXChildNode(), d = this.parseJSXBoundaryElement(); if (d.type === i.JSXSyntax.JSXOpeningElement) { var e = d; if (e.selfClosing) { var f = this.finalize(c, new k.JSXElement(e, [], null)); a.children.push(f) } else b.push(a), a = { node: c, opening: e, closing: null, children: [] } } if (d.type === i.JSXSyntax.JSXClosingElement) { a.closing = d; var g = m(a.opening.name), h = m(a.closing.name); if (g !== h && this.tolerateError("Expected corresponding JSX closing tag for %0", g), !(b.length > 0)) break; var f = this.finalize(a.node, new k.JSXElement(a.opening, a.children, a.closing)); a = b.pop(), a.children.push(f) } } return a }, b.prototype.parseJSXElement = function () { var a = this.createJSXNode(), b = this.parseJSXOpeningElement(), c = [], d = null; if (!b.selfClosing) { var e = this.parseComplexJSXElement({ node: a, opening: b, closing: d, children: c }); c = e.children, d = e.closing } return this.finalize(a, new k.JSXElement(b, c, d)) }, b.prototype.parseJSXRoot = function () { this.config.tokens && this.tokens.pop(), this.startJSX(); var a = this.parseJSXElement(); return this.finishJSX(), a }, b }(g.Parser); b.JSXParser = n }, function (a, b) { "use strict"; b.XHTMLEntities = { quot: '"', amp: "&", apos: "'", gt: ">", nbsp: " ", iexcl: "¡", cent: "¢", pound: "£", curren: "¤", yen: "¥", brvbar: "¦", sect: "§", uml: "¨", copy: "©", ordf: "ª", laquo: "«", not: "¬", shy: "­", reg: "®", macr: "¯", deg: "°", plusmn: "±", sup2: "²", sup3: "³", acute: "´", micro: "µ", para: "¶", middot: "·", cedil: "¸", sup1: "¹", ordm: "º", raquo: "»", frac14: "¼", frac12: "½", frac34: "¾", iquest: "¿", Agrave: "À", Aacute: "Á", Acirc: "Â", Atilde: "Ã", Auml: "Ä", Aring: "Å", AElig: "Æ", Ccedil: "Ç", Egrave: "È", Eacute: "É", Ecirc: "Ê", Euml: "Ë", Igrave: "Ì", Iacute: "Í", Icirc: "Î", Iuml: "Ï", ETH: "Ð", Ntilde: "Ñ", Ograve: "Ò", Oacute: "Ó", Ocirc: "Ô", Otilde: "Õ", Ouml: "Ö", times: "×", Oslash: "Ø", Ugrave: "Ù", Uacute: "Ú", Ucirc: "Û", Uuml: "Ü", Yacute: "Ý", THORN: "Þ", szlig: "ß", agrave: "à", aacute: "á", acirc: "â", atilde: "ã", auml: "ä", aring: "å", aelig: "æ", ccedil: "ç", egrave: "è", eacute: "é", ecirc: "ê", euml: "ë", igrave: "ì", iacute: "í", icirc: "î", iuml: "ï", eth: "ð", ntilde: "ñ", ograve: "ò", oacute: "ó", ocirc: "ô", otilde: "õ", ouml: "ö", divide: "÷", oslash: "ø", ugrave: "ù", uacute: "ú", ucirc: "û", uuml: "ü", yacute: "ý", thorn: "þ", yuml: "ÿ", OElig: "Œ", oelig: "œ", Scaron: "Š", scaron: "š", Yuml: "Ÿ", fnof: "ƒ", circ: "ˆ", tilde: "˜", Alpha: "Α", Beta: "Β", Gamma: "Γ", Delta: "Δ", Epsilon: "Ε", Zeta: "Ζ", Eta: "Η", Theta: "Θ", Iota: "Ι", Kappa: "Κ", Lambda: "Λ", Mu: "Μ", Nu: "Ν", Xi: "Ξ", Omicron: "Ο", Pi: "Π", Rho: "Ρ", Sigma: "Σ", Tau: "Τ", Upsilon: "Υ", Phi: "Φ", Chi: "Χ", Psi: "Ψ", Omega: "Ω", alpha: "α", beta: "β", gamma: "γ", delta: "δ", epsilon: "ε", zeta: "ζ", eta: "η", theta: "θ", iota: "ι", kappa: "κ", lambda: "λ", mu: "μ", nu: "ν", xi: "ξ", omicron: "ο", pi: "π", rho: "ρ", sigmaf: "ς", sigma: "σ", tau: "τ", upsilon: "υ", phi: "φ", chi: "χ", psi: "ψ", omega: "ω", thetasym: "ϑ", upsih: "ϒ", piv: "ϖ", ensp: " ", emsp: " ", thinsp: " ", zwnj: "‌", zwj: "‍", lrm: "‎", rlm: "‏", ndash: "–", mdash: "—", lsquo: "‘", rsquo: "’", sbquo: "‚", ldquo: "“", rdquo: "”", bdquo: "„", dagger: "†", Dagger: "‡", bull: "•", hellip: "…", permil: "‰", prime: "′", Prime: "″", lsaquo: "‹", rsaquo: "›", oline: "‾", frasl: "⁄", euro: "€", image: "ℑ", weierp: "℘", real: "ℜ", trade: "™", alefsym: "ℵ", larr: "←", uarr: "↑", rarr: "→", darr: "↓", harr: "↔", crarr: "↵", lArr: "⇐", uArr: "⇑", rArr: "⇒", dArr: "⇓", hArr: "⇔", forall: "∀", part: "∂", exist: "∃", empty: "∅", nabla: "∇", isin: "∈", notin: "∉", ni: "∋", prod: "∏", sum: "∑", minus: "−", lowast: "∗", radic: "√", prop: "∝", infin: "∞", ang: "∠", and: "∧", or: "∨", cap: "∩", cup: "∪", int: "∫", there4: "∴", sim: "∼", cong: "≅", asymp: "≈", ne: "≠", equiv: "≡", le: "≤", ge: "≥", sub: "⊂", sup: "⊃", nsub: "⊄", sube: "⊆", supe: "⊇", oplus: "⊕", otimes: "⊗", perp: "⊥", sdot: "⋅", lceil: "⌈", rceil: "⌉", lfloor: "⌊", rfloor: "⌋", loz: "◊", spades: "♠", clubs: "♣", hearts: "♥", diams: "♦", lang: "⟨", rang: "⟩" } }, function (a, b) { "use strict"; b.JSXSyntax = { JSXAttribute: "JSXAttribute", JSXClosingElement: "JSXClosingElement", JSXElement: "JSXElement", JSXEmptyExpression: "JSXEmptyExpression", JSXExpressionContainer: "JSXExpressionContainer", JSXIdentifier: "JSXIdentifier", JSXMemberExpression: "JSXMemberExpression", JSXNamespacedName: "JSXNamespacedName", JSXOpeningElement: "JSXOpeningElement", JSXSpreadAttribute: "JSXSpreadAttribute", JSXText: "JSXText" } }, function (a, b, c) { "use strict"; var d = c(13), e = function () { function a(a) { this.type = d.JSXSyntax.JSXClosingElement, this.name = a } return a }(); b.JSXClosingElement = e; var f = function () { function a(a, b, c) { this.type = d.JSXSyntax.JSXElement, this.openingElement = a, this.children = b, this.closingElement = c } return a }(); b.JSXElement = f; var g = function () { function a() { this.type = d.JSXSyntax.JSXEmptyExpression } return a }(); b.JSXEmptyExpression = g; var h = function () { function a(a) { this.type = d.JSXSyntax.JSXExpressionContainer, this.expression = a } return a }(); b.JSXExpressionContainer = h; var i = function () { function a(a) { this.type = d.JSXSyntax.JSXIdentifier, this.name = a } return a }(); b.JSXIdentifier = i; var j = function () { function a(a, b) { this.type = d.JSXSyntax.JSXMemberExpression, this.object = a, this.property = b } return a }(); b.JSXMemberExpression = j; var k = function () { function a(a, b) { this.type = d.JSXSyntax.JSXAttribute, this.name = a, this.value = b } return a }(); b.JSXAttribute = k; var l = function () { function a(a, b) { this.type = d.JSXSyntax.JSXNamespacedName, this.namespace = a, this.name = b } return a }(); b.JSXNamespacedName = l; var m = function () { function a(a, b, c) { this.type = d.JSXSyntax.JSXOpeningElement, this.name = a, this.selfClosing = b, this.attributes = c } return a }(); b.JSXOpeningElement = m; var n = function () { function a(a) { this.type = d.JSXSyntax.JSXSpreadAttribute, this.argument = a } return a }(); b.JSXSpreadAttribute = n; var o = function () { function a(a, b) { this.type = d.JSXSyntax.JSXText, this.value = a, this.raw = b } return a }(); b.JSXText = o }, function (a, b, c) { "use strict"; var d = c(8), e = c(6), f = c(7), g = function () { function a() { this.values = [], this.curly = this.paren = -1 } return a.prototype.beforeFunctionExpression = function (a) { return ["(", "{", "[", "in", "typeof", "instanceof", "new", "return", "case", "delete", "throw", "void", "=", "+=", "-=", "*=", "**=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "|=", "^=", ",", "+", "-", "*", "**", "/", "%", "++", "--", "<<", ">>", ">>>", "&", "|", "^", "!", "~", "&&", "||", "?", ":", "===", "==", ">=", "<=", "<", ">", "!=", "!=="].indexOf(a) >= 0 }, a.prototype.isRegexStart = function () { var a = this.values[this.values.length - 1], b = null !== a; switch (a) { case "this": case "]": b = !1; break; case ")": var c = this.values[this.paren - 1]; b = "if" === c || "while" === c || "for" === c || "with" === c; break; case "}": if (b = !1, "function" === this.values[this.curly - 3]) { var d = this.values[this.curly - 4]; b = !!d && !this.beforeFunctionExpression(d) } else if ("function" === this.values[this.curly - 4]) { var e = this.values[this.curly - 5]; b = !e || !this.beforeFunctionExpression(e) } } return b }, a.prototype.push = function (a) { a.type === f.Token.Punctuator || a.type === f.Token.Keyword ? ("{" === a.value ? this.curly = this.values.length : "(" === a.value && (this.paren = this.values.length), this.values.push(a.value)) : this.values.push(null) }, a }(), h = function () { function a(a, b) { this.errorHandler = new e.ErrorHandler, this.errorHandler.tolerant = !!b && ("boolean" == typeof b.tolerant && b.tolerant), this.scanner = new d.Scanner(a, this.errorHandler), this.scanner.trackComment = !!b && ("boolean" == typeof b.comment && b.comment), this.trackRange = !!b && ("boolean" == typeof b.range && b.range), this.trackLoc = !!b && ("boolean" == typeof b.loc && b.loc), this.buffer = [], this.reader = new g } return a.prototype.errors = function () { return this.errorHandler.errors }, a.prototype.getNextToken = function () { if (0 === this.buffer.length) { var a = this.scanner.scanComments(); if (this.scanner.trackComment) for (var b = 0; b < a.length; ++b) { var c = a[b], d = void 0, e = this.scanner.source.slice(c.slice[0], c.slice[1]); d = { type: c.multiLine ? "BlockComment" : "LineComment", value: e }, this.trackRange && (d.range = c.range), this.trackLoc && (d.loc = c.loc), this.buffer.push(d) } if (!this.scanner.eof()) { var g = void 0; this.trackLoc && (g = { start: { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, end: {} }); var h = void 0; h = "/" === this.scanner.source[this.scanner.index] ? this.reader.isRegexStart() ? this.scanner.scanRegExp() : this.scanner.scanPunctuator() : this.scanner.lex(), this.reader.push(h); var i = void 0; i = { type: f.TokenName[h.type], value: this.scanner.source.slice(h.start, h.end) }, this.trackRange && (i.range = [h.start, h.end]), this.trackLoc && (g.end = { line: this.scanner.lineNumber, column: this.scanner.index - this.scanner.lineStart }, i.loc = g), h.regex && (i.regex = h.regex), this.buffer.push(i) } } return this.buffer.shift() }, a }(); b.Tokenizer = h }])
});